/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dist/xtend.js":
/*!***********************!*\
  !*** ./dist/xtend.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var xtend_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xtend-library */ "./src/xt.js");
/* harmony import */ var xtend_library_src_xtend_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xtend-library/src/xtend-core.js */ "./src/xtend-core.js");
/* harmony import */ var xtend_library_src_xtend_core_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(xtend_library_src_xtend_core_js__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! Xtend (https://getxtend.com/)
@copyright (c) 2017 - 2019 Riccardo Caroli
@license MIT (https://github.com/minimit/xtend-library/blob/master/LICENSE) */
// support explorer 15, firefox 48, opera 34, safari 10, chrome 47
// support old browsers ie11+
// ADD
// .browserslistrc ie >= 11
// import 'xtend-library/src/polyfill-ie11.js'
// POLYFILLS
// ADD
// https://cdnjs.cloudflare.com/ajax/libs/core-js/2.6.9/shim.min.js
// OR
// import 'core-js'
// import 'regenerator-runtime/runtime'

 // export UMD

(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js") ? define(factory) : (global = global || self, global.Xt = factory());
})(undefined, function () {
  'use strict';

  return xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"];
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./dist/xtend.less":
/*!*************************!*\
  !*** ./dist/xtend.less ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (originalModule) {
  if (!originalModule.webpackPolyfill) {
    var module = Object.create(originalModule); // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    Object.defineProperty(module, "exports", {
      enumerable: true
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),

/***/ "./src/core/ajax/ajax.js":
/*!*******************************!*\
  !*** ./src/core/ajax/ajax.js ***!
  \*******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var xtend_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xtend-library */ "./src/xt.js");
/* harmony import */ var xtend_library_src_core_toggle_toggle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xtend-library/src/core/toggle/toggle.js */ "./src/core/toggle/toggle.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var Ajax =
/*#__PURE__*/
function (_Xt$Toggle) {
  _inherits(Ajax, _Xt$Toggle);

  /**
   * constructor
   * @param {Node|HTMLElement|EventTarget|Window} object Base node
   * @param {Object} optionsJs User options
   * @constructor
   */
  function Ajax(object) {
    var _this;

    var optionsJs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Ajax);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Ajax).call(this, object, optionsJs)); // prevent scroll on popstate

    if ('scrollRestoration' in history) {
      history.scrollRestoration = 'manual';
    }

    return _this;
  } //
  // init
  //

  /**
   * init
   */


  _createClass(Ajax, [{
    key: "init",
    value: function init() {
      var self = this; // vars

      self.locationFrom = self.locationTo || null; // fix popstate

      self.locationTo = null; // super

      _get(_getPrototypeOf(Ajax.prototype), "init", this).call(this);
    }
    /**
     * init setup
     */

  }, {
    key: "initSetup",
    value: function initSetup() {
      _get(_getPrototypeOf(Ajax.prototype), "initSetup", this).call(this);

      var self = this;
      var options = self.options; // queryElement

      self.queryElement = self.object.querySelector(options.query) || self.object;
    }
    /**
     * init elements
     */

  }, {
    key: "initScopeElements",
    value: function initScopeElements() {
      _get(_getPrototypeOf(Ajax.prototype), "initScopeElements", this).call(this);

      var self = this; // remove external links

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var element = _step.value;

          if (location.hostname !== element.hostname || element.getAttribute('href').split('#')[0] === '') {
            self.elements = Array.from(self.elements).filter(function (x) {
              return x !== element;
            });
          }
        };

        for (var _iterator = self.elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        } // generate groups

      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      self.groupUrl = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = self.elements[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var element = _step2.value;
          // populate
          var url = element.getAttribute('href').split('#')[0];

          if (!self.groupUrl[url]) {
            self.groupUrl[url] = [];
          }

          self.groupUrl[url].push(element); // assign group

          element.setAttribute('data-xt-group', self.namespace + '-' + url);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
    /**
     * init start
     * @param {Boolean} saveCurrents
     */

  }, {
    key: "initStart",
    value: function initStart() {
      var saveCurrents = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var self = this; // initial

      self.initial = true;
      self.currentIndex = null; // automatic initial currents

      var elements = self.getGroups();

      if (elements.length) {
        var found = false;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = elements[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var element = _step3.value;
            var loc = location.pathname + location.search;

            var _url = element.pathname + element.search;

            if (_url !== '') {
              if (loc === _url) {
                found = true; // activate

                self.eventOn(element, true);
              } else {
                // deactivate
                self.eventOff(element, true);
              }
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        if (!found) {
          // initial
          self.initial = false;
        }
      } else {
        // initial
        self.initial = false;
      } // detect url


      var url;

      if (history.state && history.state.url) {
        // detect from history
        url = history.state.url;
      } else {
        // detect from url location (absolute url without domain name)
        url = location.pathname + location.search;
      } // set pushstate


      if (!self.locationFrom) {
        self.locationFrom = new URL(url, location);
      }

      self.pushState(url, document.title); // init events

      self.initEvents(); // listener dispatch

      requestAnimationFrame(function () {
        var detail = self.eDetailSet();
        self.object.dispatchEvent(new CustomEvent('init.xt', {
          detail: detail
        }));
      });
    }
    /**
     * init events
     */

  }, {
    key: "initEvents",
    value: function initEvents() {
      _get(_getPrototypeOf(Ajax.prototype), "initEvents", this).call(this);

      var self = this; // event popstate

      window.onpopstate = self.eventPopstateHandler.bind(self);
    } //
    // handler
    //

    /**
     * element on handler
     * @param {Node|HTMLElement|EventTarget|Window} element
     * @param {Event} e
     */

  }, {
    key: "eventOnHandler",
    value: function eventOnHandler(element, e) {
      if (!e || !e.detail || !e.detail.skip) {
        // @FIX filter triggered from library (use only in library)
        // not when opening in new tab
        if (e.metaKey || e.ctrlKey) {
          return;
        } // prevent links (needed for xt-ajax to go to links and propagate event if inside targets)


        e.preventDefault();
      } // super


      _get(_getPrototypeOf(Ajax.prototype), "eventOnHandler", this).call(this, element, e);
    }
    /**
     * element popstate handler
     * @param {Event} e
     */

  }, {
    key: "eventPopstateHandler",
    value: function eventPopstateHandler(e) {
      var self = this; // handler

      if (history.state && history.state.url) {
        // reinit currents
        self.initStart(); // request set

        requestAnimationFrame(function () {
          self.ajaxRequest(null, history.state.url);
        });
      }
    } //
    // queue
    //

    /**
     * logic to execute on queue complete
     * @param {String} actionCurrent Current action
     * @param {Object} obj Queue object
     */

  }, {
    key: "queueComplete",
    value: function queueComplete(actionCurrent, obj) {
      var self = this;

      if (actionCurrent === 'On') {
        if (!self.initial) {
          // trigger ajax request
          self.ajaxRequest(obj.elements.queueEls[0], null);
        }
      }

      _get(_getPrototypeOf(Ajax.prototype), "queueComplete", this).call(this, actionCurrent, obj);
    } //
    // special
    //

    /**
     * ajax request
     * @param {Node|HTMLElement|EventTarget|Window} element Base node
     * @param {String} url Url to get
     */

  }, {
    key: "ajaxRequest",
    value: function ajaxRequest(element, url) {
      var self = this;
      var options = self.options; // url

      if (element) {
        url = element.getAttribute('href').split('#')[0];
      } // location


      self.locationFrom = self.locationTo || self.locationFrom; // fix fast change page

      self.locationTo = new URL(url, location); // autoClose

      dispatchEvent(new CustomEvent('autoClose.xt')); // dispatch

      var detail = self.eDetailSet();
      self.object.dispatchEvent(new CustomEvent('request.xt.ajax', {
        detail: detail
      })); // duration

      self.detail.requestDate = new Date();
      clearTimeout(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(self.object, self.componentNamespace + 'AjaxDurationTimeout'));

      if (self.detail.request) {
        self.detail.request.abort();
      } // fix fast change page


      requestAnimationFrame(function () {
        self.detail.requestDuration = options.duration || xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].animTime(self.queryElement); // call

        var request = new XMLHttpRequest();
        request.open('GET', url, true);

        request.onload = function () {
          self.ajaxResponse(element, url, request, self.detail.requestDate);
        };

        request.onerror = function () {
          self.ajaxResponse(element, url, request, self.detail.requestDate);
        };

        if (xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].debug === true) {
          console.debug('xt-ajax request:', url);
        }

        request.send();
        self.detail.request = request;
      });
    }
    /**
     * ajax response
     * @param {Node|HTMLElement|EventTarget|Window} element Base node
     * @param {String} url Url to get
     * @param {XMLHttpRequest} request Html response
     * @param {Date} date Html response
     */

  }, {
    key: "ajaxResponse",
    value: function ajaxResponse(element, url, request, date) {
      var self = this; // dispatch

      var detail = self.eDetailSet();
      self.object.dispatchEvent(new CustomEvent('response.xt.ajax', {
        detail: detail
      })); // duration

      self.detail.requestDuration -= new Date() - date;

      if (self.detail.requestDuration > 0) {
        xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(self.object, self.componentNamespace + 'AjaxDurationTimeout', setTimeout(function () {
          // request
          if (request.status >= 200 && request.status <= 300) {
            self.ajaxSuccess(element, url, request, date);
          } else {
            self.ajaxError(element, url, request);
          }
        }, self.detail.requestDuration));
      } else {
        // request
        if (request.status >= 200 && request.status <= 300) {
          self.ajaxSuccess(element, url, request, date);
        } else {
          self.ajaxError(element, url, request);
        }
      }
    }
    /**
     * ajax success
     * @param {Node|HTMLElement|EventTarget|Window} element Base node
     * @param {String} url Url to get
     * @param {XMLHttpRequest} request Html response
     * @param {Date} date Html response
     */

  }, {
    key: "ajaxSuccess",
    value: function ajaxSuccess(element, url, request, date) {
      var self = this;
      var options = self.options; // debug

      if (xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].debug === true) {
        console.debug('xt-ajax request success:', url);
      } // set substitute


      var html = document.createElement('html');
      html.innerHTML = request.responseText.trim();
      var title = html.querySelector('head title').innerHTML;
      var replace = html.querySelector(options.query); // populate dom

      self.queryElement.outerHTML = replace.outerHTML; // queryElement

      self.queryElement = self.object.querySelector(options.query) || self.object; // pushstate

      self.pushState(url, title); // garbage collector

      html = null;
      replace = null; // dispatch

      var detail = self.eDetailSet();
      self.object.dispatchEvent(new CustomEvent('replace.xt.ajax', {
        detail: detail
      })); // reinit

      if (!self.initial && date === self.detail.requestDate) {
        // fix fast change page
        requestAnimationFrame(function () {
          self.initial = true;
          self.init();
        });
      }
    }
    /**
     * ajax error
     * @param {Node|HTMLElement|EventTarget|Window} element Base node
     * @param {String} url Url to get
     * @param {XMLHttpRequest} request Html response
     */

  }, {
    key: "ajaxError",
    value: function ajaxError(element, url, request) {
      var self = this; // debug

      if (xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].debug === true) {
        console.debug('xt-ajax request failed:', url);
      } // reinit currents


      self.initStart(); // dispatch

      var detail = self.eDetailSet();
      self.object.dispatchEvent(new CustomEvent('replace.xt.ajax', {
        detail: detail
      }));
    }
    /**
     * history pushstate
     */

  }, {
    key: "pushState",
    value: function pushState(url, title) {
      // push object state
      if (!history.state || !history.state.url || history.state.url !== url) {
        document.title = title;
        history.pushState({
          url: url,
          title: title
        }, title, url);
      } else {
        document.title = history.state.title;
      }
    }
  }]);

  return Ajax;
}(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Toggle); //
// option
//


Ajax.componentName = 'xt-ajax';
Ajax.optionsDefault = {
  elements: 'a[href]:not([href^=#])',
  targets: false,
  on: 'click',
  min: 0,
  max: 1,
  instant: true,
  query: 'body',
  // needs to be unique
  baseUrl: '/',
  duration: false,
  aria: false //
  // export
  //

};
xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Ajax = Ajax; //
// observe
//

xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].mount.push({
  matches: '[data-' + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Ajax.componentName + ']',
  mount: function mount(object) {
    // init
    var self = new xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Ajax(object, object.getAttribute('data-' + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Ajax.componentName)); // unmount

    return function unmount() {
      self.destroy();
      self = null;
    };
  }
});

/***/ }),

/***/ "./src/core/drop/drop.js":
/*!*******************************!*\
  !*** ./src/core/drop/drop.js ***!
  \*******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var xtend_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xtend-library */ "./src/xt.js");
/* harmony import */ var xtend_library_src_core_toggle_toggle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xtend-library/src/core/toggle/toggle.js */ "./src/core/toggle/toggle.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var Drop =
/*#__PURE__*/
function (_Xt$Toggle) {
  _inherits(Drop, _Xt$Toggle);

  /**
   * constructor
   * @param {Node|HTMLElement|EventTarget|Window} object Base node
   * @param {Object} optionsJs User options
   * @constructor
   */
  function Drop(object) {
    var optionsJs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Drop);

    return _possibleConstructorReturn(this, _getPrototypeOf(Drop).call(this, object, optionsJs));
  } //
  // init
  //

  /**
   * init aria
   */


  _createClass(Drop, [{
    key: "initAriaRole",
    value: function initAriaRole() {
      var self = this;
      var options = self.options; // aria

      if (options.aria) {
        // role
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = self.elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var el = _step.value;
            var ariaEls = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].queryAll(el, options.ariaControls);
            var ariaEl = ariaEls.length ? ariaEls[0] : el;
            ariaEl.setAttribute('aria-haspopup', 'listbox');
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = self.targets[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var tr = _step2.value;
            tr.setAttribute('role', 'listbox');
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }
  }]);

  return Drop;
}(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Toggle); //
// option
//


Drop.componentName = 'xt-drop';
Drop.optionsDefault = {
  elements: false,
  targets: ':scope > .drop',
  elementsInner: ':scope > a, :scope > button',
  on: 'click',
  min: 0,
  max: 1,
  instant: {
    elementsInner: true
  },
  autoClose: true,
  closeOutside: 'body',
  ariaControls: ':scope > a, :scope > button' //
  // export
  //

};
xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Drop = Drop; //
// observe
//

xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].mount.push({
  matches: '[data-' + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Drop.componentName + ']',
  mount: function mount(object) {
    // init
    var self = new xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Drop(object, object.getAttribute('data-' + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Drop.componentName)); // unmount

    return function unmount() {
      self.destroy();
      self = null;
    };
  }
});

/***/ }),

/***/ "./src/core/overlay/overlay.js":
/*!*************************************!*\
  !*** ./src/core/overlay/overlay.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var xtend_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xtend-library */ "./src/xt.js");
/* harmony import */ var xtend_library_src_core_toggle_toggle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xtend-library/src/core/toggle/toggle.js */ "./src/core/toggle/toggle.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var Overlay =
/*#__PURE__*/
function (_Xt$Toggle) {
  _inherits(Overlay, _Xt$Toggle);

  /**
   * constructor
   * @param {Node|HTMLElement|EventTarget|Window} object Base node
   * @param {Object} optionsJs User options
   * @constructor
   */
  function Overlay(object) {
    var optionsJs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Overlay);

    return _possibleConstructorReturn(this, _getPrototypeOf(Overlay).call(this, object, optionsJs));
  } //
  // init
  //

  /**
   * init aria
   */


  _createClass(Overlay, [{
    key: "initAriaRole",
    value: function initAriaRole() {
      var self = this;
      var options = self.options; // aria

      if (options.aria) {
        // role
        if (self.targets.length) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = self.elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var el = _step.value;
              var ariaEls = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].queryAll(el, options.ariaControls);
              var ariaEl = ariaEls.length ? ariaEls[0] : el;
              ariaEl.setAttribute('aria-haspopup', 'dialog');
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = self.targets[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var tr = _step2.value;
              tr.setAttribute('role', 'dialog');
              tr.setAttribute('aria-modal', 'true');
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        } else {
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = self.elements[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _el = _step3.value;

              _el.setAttribute('role', 'dialog');

              _el.setAttribute('aria-modal', 'true');
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      }
    }
  }]);

  return Overlay;
}(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Toggle); //
// option
//


Overlay.componentName = 'xt-overlay';
Overlay.optionsDefault = {
  elements: ':scope > a, :scope > button',
  targets: ':scope > .overlay_outer',
  on: 'click',
  min: 0,
  max: 1,
  instant: {
    elements: true
  },
  autoClose: true,
  appendTo: 'body',
  backdrop: 'targets',
  classHtml: 'xt-overlay',
  closeInside: '.overlay_dismiss, :scope > .backdrop',
  scrollbar: true //
  // export
  //

};
xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Overlay = Overlay; //
// observe
//

xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].mount.push({
  matches: '[data-' + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Overlay.componentName + ']',
  mount: function mount(object) {
    // init
    var self = new xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Overlay(object, object.getAttribute('data-' + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Overlay.componentName)); // unmount

    return function unmount() {
      self.destroy();
      self = null;
    };
  }
});

/***/ }),

/***/ "./src/core/scroll/scroll.js":
/*!***********************************!*\
  !*** ./src/core/scroll/scroll.js ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var xtend_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xtend-library */ "./src/xt.js");
/* harmony import */ var xtend_library_src_core_toggle_toggle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xtend-library/src/core/toggle/toggle.js */ "./src/core/toggle/toggle.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var Scroll =
/*#__PURE__*/
function (_Xt$Toggle) {
  _inherits(Scroll, _Xt$Toggle);

  /**
   * constructor
   * @param {Node|HTMLElement|EventTarget|Window} object Base node
   * @param {Object} optionsJs User options
   * @constructor
   */
  function Scroll(object) {
    var optionsJs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Scroll);

    return _possibleConstructorReturn(this, _getPrototypeOf(Scroll).call(this, object, optionsJs));
  } //
  // init
  //

  /**
   * init elements, targets and currents
   */


  _createClass(Scroll, [{
    key: "initScope",
    value: function initScope() {
      _get(_getPrototypeOf(Scroll.prototype), "initScope", this).call(this);

      var self = this;
      var options = self.options; // loop

      self.targets = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = self.elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var el = _step.value;

          if (!options.sticky) {
            // not sticky
            self.targets.push(el);
          } else {
            // sticky container
            var container = el.closest('.xt-container');

            if (!container) {
              container = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].createElement('<div class="xt-container xt-fixed--check"></div>');
              el.before(container);
              el.classList.add('xt-ignore', 'xt-ignore--once'); // @FIX ignore once for mount when moving

              container.append(el);
            } // sticky clone


            var target = container.querySelector('.xt-clone');

            if (!target) {
              target = el.cloneNode(true);
              target.classList.add('xt-clone', 'xt-ignore');
              target.classList.remove('xt-ignore--once'); // @FIX ignore once for mount when moving

              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = target.querySelectorAll('[id]')[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var elId = _step2.value;
                  elId.setAttribute('id', elId.getAttribute('id') + '-clone');
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                    _iterator2.return();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }

              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (var _iterator3 = target.querySelectorAll('[name]')[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var elName = _step3.value;
                  elName.setAttribute('name', elName.getAttribute('name') + '-clone');
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                    _iterator3.return();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }

              container.append(target);
            }

            self.targets.push(target); // sticky

            el.classList.add('xt-fixed', 'xt-sticky');

            if (options.sticky === 'absolute') {
              el.classList.add('xt-sticky--absolute');
            } else if (options.sticky === 'fixed') {
              el.classList.add('xt-sticky--fixed');
            } else if (options.sticky === 'fixed-always') {
              el.classList.add('xt-sticky--fixed-always');
            }

            if (target) {
              target.classList.add('xt-fixed', 'xt-sticky');

              if (options.sticky === 'absolute') {
                target.classList.add('xt-sticky--absolute');
              } else if (options.sticky === 'fixed') {
                target.classList.add('xt-sticky--fixed');
              } else if (options.sticky === 'fixed-always') {
                target.classList.add('xt-sticky--fixed-always');
              }
            }
          } // indicator


          if (el.classList.contains('indicator')) {
            var indicatorTrigger = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].createElement('<div class="xt-ignore xt-indicator xt-indicator--trigger"></div>');
            document.body.append(indicatorTrigger);
            var indicatorStart = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].createElement('<div class="xt-ignore xt-indicator xt-indicator--start"></div>');
            document.body.append(indicatorStart);
            var indicatorEnd = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].createElement('<div class="xt-ignore xt-indicator xt-indicator--end"></div>');
            document.body.append(indicatorEnd);
            var indicatorStartReal = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].createElement('<div class="xt-ignore xt-indicator xt-indicator--start-real"></div>');
            document.body.append(indicatorStartReal);
            var indicatorEndReal = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].createElement('<div class="xt-ignore xt-indicator xt-indicator--end-real"></div>');
            document.body.append(indicatorEndReal);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * init events
     */

  }, {
    key: "initEvents",
    value: function initEvents() {
      var self = this;
      var options = self.options; // event on

      if (options.on) {
        var scrollHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(window, options.on + '.' + self.namespace, self.eventScrollHandler.bind(self));

        var events = _toConsumableArray(options.on.split(' '));

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = events[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var event = _step4.value;
            addEventListener(event, scrollHandler, xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].passiveSupported ? {
              passive: true
            } : false);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        requestAnimationFrame(function () {
          self.eventScrollHandler(null, true);
        });
      }
    } //
    // handler
    //

    /**
     * element on handler
     * @param {Event} e
     * @param {Boolean} initial
     */

  }, {
    key: "eventScrollHandler",
    value: function eventScrollHandler() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var initial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var self = this; // handler

      if (!e || !e.detail || !e.detail.skip) {
        // @FIX filter triggered from library (use only in library)
        xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].eventDelay(e, self.object, function () {
          self.eventScroll(e, initial);
        }, self.componentNamespace + 'Resize');
      }
    } //
    // event
    //

    /**
     * window scroll
     * @param {Event} e
     * @param {Boolean} initial
     */

  }, {
    key: "eventScroll",
    value: function eventScroll(e, initial) {
      var self = this;
      var options = self.options; // disabled

      if (self.disabled && !self.initial) {
        return;
      } // vars


      var currentOn = 0;
      var currentOff = 0;
      var currentsOn = [];
      var currentsOff = [];
      var scrollingElement = document.scrollingElement;
      var scrollHeight = scrollingElement.scrollHeight;
      var scrollTop = scrollingElement.scrollTop;
      var windowHeight = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].windowHeight; // direction

      self.detail.inverseForce = scrollTop < self.detail.scrollTopOld; // loop

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        var _loop = function _loop() {
          var el = _step5.value;
          var tr = self.getTargets(el)[0];

          if (!el.classList.contains('scroll--block') && xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].visible(el) && tr.offsetParent) {
            // filter out document.documentElement
            // vars
            var changed = false;
            var elTop = tr.offsetParent.getBoundingClientRect().top + tr.offsetTop + scrollTop; // we use parents to not include transforms animations

            var elHeight = tr.offsetHeight; // size fix when position fixed

            if (options.sticky) {
              el.style.width = tr.offsetWidth + 'px';
            } // position


            self.detail.distance = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].windowPercent(options.distance);
            self.detail.trigger = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].windowPercent(options.trigger);
            self.detail.start = self.detail.startReal = elTop - windowHeight + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].windowPercent(options.start) + self.detail.distance;
            self.detail.start = self.detail.start < self.detail.trigger ? self.detail.trigger : self.detail.start; // limit fixes activation on page top

            self.detail.end = self.detail.endReal = options.end ? self.detail.start + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].windowPercent(options.end) - self.detail.distance : elTop + elHeight + self.detail.trigger - self.detail.distance;
            self.detail.end = self.detail.end > self.detail.trigger + scrollHeight - window.innerHeight ? self.detail.trigger + scrollHeight - window.innerHeight : self.detail.end; // limit fixes deactivation on page bottom

            self.detail.fallback = self.detail.end - xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].windowPercent(options.fallback);
            self.detail.start = self.detail.start > self.detail.end ? self.detail.fallback : self.detail.start; // limit fixes deactivation on page bottom
            // ratio

            var current = scrollTop + self.detail.trigger - self.detail.start;
            var total = self.detail.end - self.detail.start;
            self.detail.ratio = Math.max(0, current) / total;
            self.detail.ratio = self.detail.ratio > 0 ? self.detail.ratio : 0;
            self.detail.ratio = self.detail.ratio < 1 ? self.detail.ratio : 1;
            self.detail.ratioInverse = 1 - self.detail.ratio;
            self.detail.ratioDouble = 1 - Math.abs((self.detail.ratio - 0.5) * 2); // activation

            if (current >= 0 && current <= total || self.detail.start > self.detail.end) {
              // limit fixes activation on page top
              // inside
              changed = self.checkOn(el);

              if (changed) {
                currentsOn.push(el);
                cancelAnimationFrame(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'ScrollFrame'));
                xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'ScrollFrame', requestAnimationFrame(function () {
                  // initial
                  if (initial) {
                    xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'Initial', true);
                  } else {
                    xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.remove(el, self.componentNamespace + 'Initial');
                  } // activate


                  xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'OnCount', currentOn);
                  xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'OnTot', currentsOn.length);
                  currentOn++;
                  self.eventOn(el, true);
                }));
              }
            } else {
              // outside
              changed = self.checkOff(el);
              el.classList.add('scroll--visible');

              if (changed) {
                el.classList.add('scroll--once');
                currentsOff.push(el);
                cancelAnimationFrame(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'ScrollFrame'));
                xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'ScrollFrame', requestAnimationFrame(function () {
                  // initial
                  if (initial) {
                    xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'Initial', true);
                  } else {
                    xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.remove(el, self.componentNamespace + 'Initial');
                  } // deactivate


                  xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'OffCount', currentOff);
                  xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'OffTot', currentsOff.length);
                  currentOff++;
                  self.eventOff(el, true);
                }));
              }
            } // direction


            if (changed) {
              if (self.detail.inverseForce) {
                el.classList.add('inverse');
              } else {
                el.classList.remove('inverse');
              }
            } // indicator


            if (el.classList.contains('indicator')) {
              var triggerEl = document.body.querySelector('.xt-indicator--trigger');
              triggerEl.style.top = self.detail.trigger + 'px';
              var startEl = document.body.querySelector('.xt-indicator--start');
              startEl.style.top = self.detail.start - scrollTop + 'px';
              var endEl = document.body.querySelector('.xt-indicator--end');
              endEl.style.top = self.detail.end - scrollTop + 'px';
              var startRealEl = document.body.querySelector('.xt-indicator--start-real');
              startRealEl.style.top = self.detail.startReal - scrollTop + 'px';
              var endRealEl = document.body.querySelector('.xt-indicator--end-real');
              endRealEl.style.top = self.detail.endReal - scrollTop + 'px';
            } // dispatch


            cancelAnimationFrame(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'ScrollDispatchFrame'));
            xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'ScrollDispatchFrame', requestAnimationFrame(function () {
              var detail = self.eDetailSet();
              el.dispatchEvent(new CustomEvent('change.xt.scroll', {
                bubbles: true,
                detail: detail
              }));
            }));
          }
        };

        for (var _iterator5 = self.elements[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          _loop();
        } // save for direction

      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      cancelAnimationFrame(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(self.object, self.componentNamespace + 'ScrollObjectFrame'));
      xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(self.object, self.componentNamespace + 'ScrollDispatchFrame', requestAnimationFrame(function () {
        self.detail.scrollTopOld = scrollTop;
      }));
    }
  }]);

  return Scroll;
}(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Toggle); //
// option
//


Scroll.componentName = 'xt-scroll';
Scroll.optionsDefault = {
  elements: false,
  targets: false,
  on: 'scroll resize',
  min: 0,
  max: 'Infinity',
  instant: true,
  class: 'fade',
  classIn: 'fade--in',
  classOut: 'fade--out',
  sticky: false,
  distance: '20%',
  trigger: '100%',
  start: '100%',
  end: false,
  fallback: 100,
  aria: false //
  // export
  //

};
xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Scroll = Scroll; //
// observe
//

xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].mount.push({
  matches: '[data-' + Scroll.componentName + ']',
  mount: function mount(object) {
    // init
    var self = new xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Scroll(object, object.getAttribute('data-' + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Scroll.componentName)); // unmount

    return function unmount() {
      self.destroy();
      self = null;
    };
  }
});

/***/ }),

/***/ "./src/core/slider/slider.js":
/*!***********************************!*\
  !*** ./src/core/slider/slider.js ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var xtend_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xtend-library */ "./src/xt.js");
/* harmony import */ var xtend_library_src_core_toggle_toggle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xtend-library/src/core/toggle/toggle.js */ "./src/core/toggle/toggle.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var Slider =
/*#__PURE__*/
function (_Xt$Toggle) {
  _inherits(Slider, _Xt$Toggle);

  /**
   * constructor
   * @param {Node|HTMLElement|EventTarget|Window} object Base node
   * @param {Object} optionsJs User options
   * @constructor
   */
  function Slider(object) {
    var optionsJs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Slider);

    return _possibleConstructorReturn(this, _getPrototypeOf(Slider).call(this, object, optionsJs));
  } //
  // init
  //

  /**
   * init elements, targets and currents
   */


  _createClass(Slider, [{
    key: "initScope",
    value: function initScope() {
      var self = this;
      var options = self.options; // targets

      self.initScopeTargets(); // only one call per group

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = self.targets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var slide = _step.value;
          xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.remove(slide, self.componentNamespace + 'SlideOnDone');
        } // dragger

      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (options.drag && options.drag.dragger) {
        self.dragger = self.object.querySelector(options.drag.dragger);
        self.destroyElements.push(self.dragger);
      } // autoHeight


      if (options.autoHeight) {
        self.autoHeight = self.object.querySelector(options.autoHeight);
        self.autoHeight.classList.add('xt-autoHeight');
      } // initSliderGroup


      self.initSliderGroup(); // initSliderPags

      self.initSliderPags(); // initSliderPos

      if (self.dragger) {
        self.initSliderPos();
      } // elements


      self.initScopeElements();
    }
    /**
     * init slider group
     */

  }, {
    key: "initSliderGroup",
    value: function initSliderGroup() {
      var self = this;
      var options = self.options; // @FIX disable slider if not overflowing

      self.object.classList.remove('slider--nooverflow'); // drag wrap

      if (self.dragger && options.drag.wrap) {
        // clear elements
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = self.elements.filter(function (x) {
            return x.classList.contains('xt-wrap');
          })[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var el = _step2.value;
            el.remove();
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        self.elements = self.elements.filter(function (x) {
          return !x.classList.contains('xt-wrap');
        }); // clear targets

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = self.targets.filter(function (x) {
            return x.classList.contains('xt-wrap');
          })[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var tr = _step3.value;
            tr.remove();
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        self.targets = self.targets.filter(function (x) {
          return !x.classList.contains('xt-wrap');
        });
      } // width


      var draggerWidth = self.dragger ? self.dragger.offsetWidth : self.object.offsetWidth;
      var draggerWidthAvailable = 0; // draggerWidthAvailable

      if (options.groupMq) {
        var mqs = Object.entries(options.groupMq);

        if (mqs.length) {
          for (var _i = 0, _mqs = mqs; _i < _mqs.length; _i++) {
            var _mqs$_i = _slicedToArray(_mqs[_i], 2),
                key = _mqs$_i[0],
                value = _mqs$_i[1];

            if (window.matchMedia(key).matches) {
              draggerWidthAvailable = draggerWidth * value;
            }
          }
        }
      } // groupMqInitial


      self.groupMq = [];
      self.groupMq.push([]);
      var currentCount = draggerWidthAvailable;
      var totalCount = draggerWidth;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = self.targets[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var target = _step4.value;
          var targetWidth = target.offsetWidth;

          if (targetWidth === 0) {
            // when display none
            var _container = target.parentNode;
            var cloned = target.cloneNode(true);
            cloned.classList.add('xt-calculating', 'xt-ignore');

            _container.append(cloned);

            targetWidth = cloned.offsetWidth;
            cloned.remove();
          }

          currentCount -= targetWidth;
          totalCount -= targetWidth; // overflow

          var currentGroup = self.groupMq.length - 1;

          if (currentCount < 0 && self.groupMq[currentGroup].length) {
            self.groupMq.push([]);
            currentGroup = self.groupMq.length - 1;
            currentCount = draggerWidthAvailable;
            currentCount -= targetWidth;
          } // assign group


          self.groupMq[currentGroup].push(target);
          target.setAttribute('data-xt-group', self.namespace + '-' + currentGroup);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      self.groupMqInitial = self.groupMq; // @FIX position values negative margins

      self.detail.fixNegativeMargin = self.groupMq[0][0].offsetLeft; // @FIX disable slider if not overflowing

      if (totalCount >= 0) {
        self.object.classList.add('slider--nooverflow');
        self.disable(); // enable all visible elements also if not .active next frame when self.elements is populated

        var afterInitDisable = function afterInitDisable() {
          var currents = self.getCurrents();
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = self.elements.filter(function (x) {
              return !currents.includes(self.getElements(x)[0]);
            })[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var _el = _step5.value;
              self.activate(_el);
              var _iteratorNormalCompletion6 = true;
              var _didIteratorError6 = false;
              var _iteratorError6 = undefined;

              try {
                for (var _iterator6 = self.getTargets(_el)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                  var _tr = _step6.value;
                  self.activate(_tr);
                }
              } catch (err) {
                _didIteratorError6 = true;
                _iteratorError6 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
                    _iterator6.return();
                  }
                } finally {
                  if (_didIteratorError6) {
                    throw _iteratorError6;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }

          self.object.removeEventListener('init.xt', afterInitDisable);
        };

        self.object.addEventListener('init.xt', afterInitDisable);
      } // drag wrap


      var wrapFirst = [];
      var wrapLast = [];

      if (totalCount < 0) {
        if (self.dragger && options.drag.wrap) {
          var container = self.targets[0].parentNode;

          if (!options.loop) {
            console.error('Error: Xt.Slider needs "loop": true when using "drag": {"wrap": true}', self.object);
          }

          if (options.contain) {
            console.error('Error: Xt.Slider cannot use "contain": true when using "drag": {"wrap": true}', self.object);
          }

          var cloneSlide = function cloneSlide(slide) {
            var _cloned$classList;

            var cloned = slide.cloneNode(true);
            xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(cloned, 'xt' + self.componentNamespace + 'cloneSource', slide);
            cloned.classList.add('xt-clone', 'xt-wrap');

            (_cloned$classList = cloned.classList).remove.apply(_cloned$classList, _toConsumableArray(self.classes).concat(_toConsumableArray(self.classesIn), _toConsumableArray(self.classesOut), _toConsumableArray(self.classesInitial), _toConsumableArray(self.classesInverse)));

            return cloned;
          }; // wrapLast


          var wrapLastFunction = function wrapLastFunction() {
            var wrapLastCount = draggerWidth;
            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
              for (var _iterator7 = self.groupMqInitial.entries()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var _step7$value = _slicedToArray(_step7.value, 2),
                    i = _step7$value[0],
                    group = _step7$value[1];

                wrapLast.push([]);
                var _iteratorNormalCompletion8 = true;
                var _didIteratorError8 = false;
                var _iteratorError8 = undefined;

                try {
                  for (var _iterator8 = group[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                    var slide = _step8.value;
                    var cloned = cloneSlide(slide);
                    container.append(cloned);
                    wrapLast[i].push(cloned);
                    cloned.setAttribute('data-xt-group', self.namespace + '-' + 'wrapLast' + i);
                    self.targets.push(cloned);
                    wrapLastCount -= slide.offsetWidth;

                    if (wrapLastCount <= -draggerWidth * (options.drag.wrap - 1)) {
                      return;
                    }
                  }
                } catch (err) {
                  _didIteratorError8 = true;
                  _iteratorError8 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                      _iterator8.return();
                    }
                  } finally {
                    if (_didIteratorError8) {
                      throw _iteratorError8;
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError7 = true;
              _iteratorError7 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
                  _iterator7.return();
                }
              } finally {
                if (_didIteratorError7) {
                  throw _iteratorError7;
                }
              }
            }
          };

          wrapLastFunction(); // wrapFirst

          var wrapFirstFunction = function wrapFirstFunction() {
            var wrapFirstCount = draggerWidth;
            var _iteratorNormalCompletion9 = true;
            var _didIteratorError9 = false;
            var _iteratorError9 = undefined;

            try {
              for (var _iterator9 = self.groupMqInitial.reverse().entries()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                var _step9$value = _slicedToArray(_step9.value, 2),
                    i = _step9$value[0],
                    group = _step9$value[1];

                wrapFirst.unshift([]);
                var _iteratorNormalCompletion10 = true;
                var _didIteratorError10 = false;
                var _iteratorError10 = undefined;

                try {
                  for (var _iterator10 = group.reverse()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                    var slide = _step10.value;
                    var cloned = cloneSlide(slide);
                    container.prepend(cloned);
                    wrapFirst[0].unshift(cloned);
                    cloned.setAttribute('data-xt-group', self.namespace + '-' + 'wrapFirst' + i);
                    self.targets.unshift(cloned);
                    wrapFirstCount -= slide.offsetWidth;

                    if (wrapFirstCount <= -draggerWidth * (options.drag.wrap - 1)) {
                      return;
                    }
                  }
                } catch (err) {
                  _didIteratorError10 = true;
                  _iteratorError10 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
                      _iterator10.return();
                    }
                  } finally {
                    if (_didIteratorError10) {
                      throw _iteratorError10;
                    }
                  }
                }

                group.reverse(); // reset reverse
              }
            } catch (err) {
              _didIteratorError9 = true;
              _iteratorError9 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
                  _iterator9.return();
                }
              } finally {
                if (_didIteratorError9) {
                  throw _iteratorError9;
                }
              }
            }
          };

          wrapFirstFunction();
          self.groupMqInitial.reverse(); // reset reverse
        }
      }

      self.groupMqFirst = wrapFirst;
      self.groupMqLast = wrapLast;
      self.groupMq = wrapFirst.concat(self.groupMq.concat(wrapLast));
    }
    /**
     * init slider pagination
     */

  }, {
    key: "initSliderPags",
    value: function initSliderPags() {
      var self = this;
      var options = self.options; // generate elements

      if (options.pagination) {
        var pags = self.object.querySelectorAll(options.pagination);

        if (!pags.length) {
          console.error('Error: Xt.Slider pagination not found for', self.object);
        } // pags


        self.pags = self.pags ? self.pags : [];
        var _iteratorNormalCompletion11 = true;
        var _didIteratorError11 = false;
        var _iteratorError11 = undefined;

        try {
          for (var _iterator11 = pags.entries()[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
            var _step11$value = _slicedToArray(_step11.value, 2),
                z = _step11$value[0],
                pag = _step11$value[1];

            // clean
            if (self.pags[z]) {
              var _iteratorNormalCompletion12 = true;
              var _didIteratorError12 = false;
              var _iteratorError12 = undefined;

              try {
                for (var _iterator12 = self.pags[z][Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                  var oldPag = _step12.value;
                  oldPag.remove();
                }
              } catch (err) {
                _didIteratorError12 = true;
                _iteratorError12 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                    _iterator12.return();
                  }
                } finally {
                  if (_didIteratorError12) {
                    throw _iteratorError12;
                  }
                }
              }
            } // vars


            var cloned = pag.querySelector('[data-xt-pag]');
            cloned.classList.add('xt-ignore');
            var container = cloned.parentNode;
            var arr = self.groupMq; // populate

            self.pags[z] = [];
            var _iteratorNormalCompletion13 = true;
            var _didIteratorError13 = false;
            var _iteratorError13 = undefined;

            try {
              for (var _iterator13 = arr.entries()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                var _step13$value = _slicedToArray(_step13.value, 2),
                    i = _step13$value[0],
                    group = _step13$value[1];

                var item = document.createElement('div'); // needed to set innerHTML instead of outerHTML to do html.search also attributes

                var clone = cloned.cloneNode(true);
                clone.classList.remove('xt-ignore');
                clone.classList.add('xt-clone');
                item.appendChild(clone);
                var html = item.innerHTML;

                if (html.search(new RegExp('xt-content', 'ig')) !== -1) {
                  var replace = '';
                  var _iteratorNormalCompletion14 = true;
                  var _didIteratorError14 = false;
                  var _iteratorError14 = undefined;

                  try {
                    for (var _iterator14 = group[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
                      var slide = _step14.value;
                      replace += slide.querySelector('.slide_pagination_content').innerHTML;
                    }
                  } catch (err) {
                    _didIteratorError14 = true;
                    _iteratorError14 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
                        _iterator14.return();
                      }
                    } finally {
                      if (_didIteratorError14) {
                        throw _iteratorError14;
                      }
                    }
                  }

                  html = html.replace(new RegExp('xt-content', 'ig'), replace);
                }

                if (html.search(new RegExp('xt-num', 'ig')) !== -1) {
                  html = html.replace(new RegExp('xt-num', 'ig'), (i - self.groupMqFirst.length + 1).toString());
                }

                if (html.search(new RegExp('xt-tot', 'ig')) !== -1) {
                  html = html.replace(new RegExp('xt-tot', 'ig'), self.groupMqInitial.length.toString());
                }

                item.innerHTML = html;
                item.children[0].setAttribute('data-xt-group', group[0].getAttribute('data-xt-group'));
                container.insertBefore(item.children[0], cloned);
                item.remove();
                self.pags[z][i] = container.querySelectorAll('[data-xt-pag].xt-clone')[i]; // drag wrap

                if (self.dragger && options.drag.wrap) {
                  var min = self.groupMqFirst.length;
                  var max = self.groupMqFirst.length + self.groupMqInitial.length - 1;

                  if (i < min || i > max) {
                    self.pags[z][i].classList.add('xt-clone', 'xt-wrap', 'display--none');
                  }
                }
              }
            } catch (err) {
              _didIteratorError13 = true;
              _iteratorError13 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
                  _iterator13.return();
                }
              } finally {
                if (_didIteratorError13) {
                  throw _iteratorError13;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError11 = true;
          _iteratorError11 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
              _iterator11.return();
            }
          } finally {
            if (_didIteratorError11) {
              throw _iteratorError11;
            }
          }
        }
      }
    }
    /**
     * init slider group positions
     */

  }, {
    key: "initSliderPos",
    value: function initSliderPos() {
      var self = this;
      var options = self.options; // reset done

      var _iteratorNormalCompletion15 = true;
      var _didIteratorError15 = false;
      var _iteratorError15 = undefined;

      try {
        for (var _iterator15 = self.targets[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
          var slide = _step15.value;
          xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.remove(slide, self.componentNamespace + 'GroupPosDone');
        } // set pos

      } catch (err) {
        _didIteratorError15 = true;
        _iteratorError15 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion15 && _iterator15.return != null) {
            _iterator15.return();
          }
        } finally {
          if (_didIteratorError15) {
            throw _iteratorError15;
          }
        }
      }

      var draggerWidth = self.dragger.offsetWidth; // slides pos

      var slidesWidth = 0;
      var _iteratorNormalCompletion16 = true;
      var _didIteratorError16 = false;
      var _iteratorError16 = undefined;

      try {
        for (var _iterator16 = self.targets[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
          var _slide = _step16.value;

          if (!xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(_slide, self.componentNamespace + 'GroupPosDone') && xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].visible(_slide)) {
            // vars
            var targets = self.getTargets(_slide);
            var slideLeft = Infinity;
            var slideWidth = 0;
            var slideHeight = 0;
            var slideHeightTemp = 0; // vars

            var _iteratorNormalCompletion21 = true;
            var _didIteratorError21 = false;
            var _iteratorError21 = undefined;

            try {
              for (var _iterator21 = targets[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
                var _target = _step21.value;
                var cloneSource = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(_target, 'xt' + self.componentNamespace + 'cloneSource');
                slideLeft = _target.offsetLeft < slideLeft ? _slide.offsetLeft : slideLeft;

                if (cloneSource) {
                  // @FIX xt-wrap clone offsetWidth on resize
                  var w = cloneSource.offsetWidth;
                  slideWidth += w;
                  _target.children[0].style.width = w + 'px'; // @FIX xt-wrap clone offsetHeight on autoHeight

                  slideHeightTemp = cloneSource.children[0].offsetHeight;
                } else {
                  slideWidth += _target.offsetWidth;
                  slideHeightTemp = _target.children[0].offsetHeight;
                }

                slidesWidth += slideWidth;
                slideHeight = slideHeightTemp > slideHeight ? slideHeightTemp : slideHeight;
              }
            } catch (err) {
              _didIteratorError21 = true;
              _iteratorError21 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion21 && _iterator21.return != null) {
                  _iterator21.return();
                }
              } finally {
                if (_didIteratorError21) {
                  throw _iteratorError21;
                }
              }
            }

            var _iteratorNormalCompletion22 = true;
            var _didIteratorError22 = false;
            var _iteratorError22 = undefined;

            try {
              for (var _iterator22 = targets[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                var _target2 = _step22.value;
                xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(_target2, self.componentNamespace + 'GroupPosDone', true);
                xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(_target2, self.componentNamespace + 'GroupHeight', slideHeight);
              } // pos with alignment

            } catch (err) {
              _didIteratorError22 = true;
              _iteratorError22 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion22 && _iterator22.return != null) {
                  _iterator22.return();
                }
              } finally {
                if (_didIteratorError22) {
                  throw _iteratorError22;
                }
              }
            }

            var _pos = void 0;

            if (!self.object.classList.contains('slider--nooverflow')) {
              // @FIX disable slider if not overflowing
              if (options.align === 'center') {
                _pos = draggerWidth / 2 - slideLeft - slideWidth / 2;
              } else if (options.align === 'left') {
                _pos = -slideLeft;
              } else if (options.align === 'right') {
                _pos = draggerWidth - slideLeft - slideWidth;
              }
            } // console.debug(pos, draggerWidth, slideWidth, slide);
            // save pos


            var _iteratorNormalCompletion23 = true;
            var _didIteratorError23 = false;
            var _iteratorError23 = undefined;

            try {
              for (var _iterator23 = targets[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
                var _target3 = _step23.value;
                xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(_target3, self.componentNamespace + 'GroupPos', _pos);
              }
            } catch (err) {
              _didIteratorError23 = true;
              _iteratorError23 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion23 && _iterator23.return != null) {
                  _iterator23.return();
                }
              } finally {
                if (_didIteratorError23) {
                  throw _iteratorError23;
                }
              }
            }
          }
        } // @FIX xt-wrap clone offsetWidth on resize

      } catch (err) {
        _didIteratorError16 = true;
        _iteratorError16 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion16 && _iterator16.return != null) {
            _iterator16.return();
          }
        } finally {
          if (_didIteratorError16) {
            throw _iteratorError16;
          }
        }
      }

      var _iteratorNormalCompletion17 = true;
      var _didIteratorError17 = false;
      var _iteratorError17 = undefined;

      try {
        for (var _iterator17 = self.targets[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
          var _target4 = _step17.value;
          _target4.children[0].style.width = '';
        } // min max pos with contain

      } catch (err) {
        _didIteratorError17 = true;
        _iteratorError17 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion17 && _iterator17.return != null) {
            _iterator17.return();
          }
        } finally {
          if (_didIteratorError17) {
            throw _iteratorError17;
          }
        }
      }

      if (options.contain && slidesWidth > draggerWidth) {
        // only if slides overflow dragger
        var slideFirst = self.targets[0];
        var slideFirstLeft = slideFirst.offsetLeft;
        var slideLast = self.targets[self.targets.length - 1];
        var slideLastLeft = slideLast.offsetLeft;
        var slideLastWidth = slideLast.offsetWidth;
        var min = -slideFirstLeft;
        var max = -slideLastLeft + draggerWidth - slideLastWidth;
        var _iteratorNormalCompletion18 = true;
        var _didIteratorError18 = false;
        var _iteratorError18 = undefined;

        try {
          for (var _iterator18 = self.groupMq[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
            var group = _step18.value;
            var _iteratorNormalCompletion19 = true;
            var _didIteratorError19 = false;
            var _iteratorError19 = undefined;

            try {
              for (var _iterator19 = group[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
                var target = _step19.value;
                var pos = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(target, self.componentNamespace + 'GroupPos');
                pos = pos > min ? min : pos;
                pos = pos < max ? max : pos;
                xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(target, self.componentNamespace + 'GroupPos', pos);
              }
            } catch (err) {
              _didIteratorError19 = true;
              _iteratorError19 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion19 && _iterator19.return != null) {
                  _iterator19.return();
                }
              } finally {
                if (_didIteratorError19) {
                  throw _iteratorError19;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError18 = true;
          _iteratorError18 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion18 && _iterator18.return != null) {
              _iterator18.return();
            }
          } finally {
            if (_didIteratorError18) {
              throw _iteratorError18;
            }
          }
        }
      } // @FIX position values negative margins


      var _iteratorNormalCompletion20 = true;
      var _didIteratorError20 = false;
      var _iteratorError20 = undefined;

      try {
        for (var _iterator20 = self.targets[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
          var _target5 = _step20.value;

          var _pos2 = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(_target5, self.componentNamespace + 'GroupPos');

          _pos2 += self.detail.fixNegativeMargin;
          xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(_target5, self.componentNamespace + 'GroupPos', _pos2);
        } // set wheel min and max

      } catch (err) {
        _didIteratorError20 = true;
        _iteratorError20 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion20 && _iterator20.return != null) {
            _iterator20.return();
          }
        } finally {
          if (_didIteratorError20) {
            throw _iteratorError20;
          }
        }
      }

      if (options.wheel && options.wheel.selector) {
        var arr = self.targets.filter(function (x) {
          return !x.classList.contains('xt-wrap');
        });
        var first = arr[0];
        var last = arr[arr.length - 1];
        self.detail.wheelMin = -xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(first, self.componentNamespace + 'GroupPos');
        self.detail.wheelMax = -xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(last, self.componentNamespace + 'GroupPos');
      }
    }
    /**
     * init events
     */

  }, {
    key: "initEvents",
    value: function initEvents() {
      _get(_getPrototypeOf(Slider.prototype), "initEvents", this).call(this);

      var self = this;
      var options = self.options;
      var dragger = self.dragger; // targets

      var _iteratorNormalCompletion24 = true;
      var _didIteratorError24 = false;
      var _iteratorError24 = undefined;

      try {
        for (var _iterator24 = self.targets[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
          var slide = _step24.value;

          // disable links not active slide
          if (options.jump) {
            slide.classList.add('links--none');
          } // slide on


          var slideOnHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(slide, 'on' + '.' + self.namespace, self.eventSlideOnHandler.bind(self).bind(self, dragger, slide));
          slide.addEventListener('on.xt', slideOnHandler, true); // @FIX event.xt: useCapture for custom events order on re-init
          // slide off

          var slideOffHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(slide, 'off' + '.' + self.namespace, self.eventSlideOffHandler.bind(self).bind(self, dragger, slide));
          slide.addEventListener('off.xt', slideOffHandler, true); // @FIX event.xt: useCapture for custom events order on re-init
        } // dragger

      } catch (err) {
        _didIteratorError24 = true;
        _iteratorError24 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion24 && _iterator24.return != null) {
            _iterator24.return();
          }
        } finally {
          if (_didIteratorError24) {
            throw _iteratorError24;
          }
        }
      }

      if (options.drag) {
        // drag start
        var dragstartHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(dragger, 'mousedown touchstart' + '.' + self.namespace, self.eventDragstartHandler.bind(self).bind(self, dragger));
        var events = ['mousedown', 'touchstart'];

        for (var _i2 = 0, _events = events; _i2 < _events.length; _i2++) {
          var event = _events[_i2];
          dragger.addEventListener(event, dragstartHandler, xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].passiveSupported ? {
            passive: true
          } : false);
        } // grab


        if (!self.disabled) {
          dragger.classList.add('grab');
        } else {
          dragger.classList.remove('grab');
        } // wheel


        if (options.wheel && options.wheel.selector) {
          var wheel = self.detail.wheel;
          wheel.addEventListener('wheelstart.xt', self.logicDragstart.bind(self).bind(self, dragger));
          wheel.addEventListener('wheel.xt', self.logicDrag.bind(self).bind(self, dragger));
          wheel.addEventListener('wheelend.xt', self.logicDragend.bind(self).bind(self, dragger));
          wheel.addEventListener('wheelend.xt', self.logicDragfrictionend.bind(self).bind(self, dragger));
        }
      } // resize


      var resizeHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(window, 'resize' + '.' + self.namespace, self.eventResizeHandler.bind(self).bind(self));
      addEventListener('resize', resizeHandler);
    } //
    // handler
    //

    /**
     * slide on handler
     * @param {Node|HTMLElement|EventTarget|Window} dragger
     * @param {Node|HTMLElement|EventTarget|Window} slide
     * @param {Event} e
     */

  }, {
    key: "eventSlideOnHandler",
    value: function eventSlideOnHandler(dragger, slide, e) {
      var self = this; // handler

      if (slide === e.target) {
        // @FIX on.xt and off.xt event bubbles
        self.eventSlideOn(dragger, e);
      }
    }
    /**
     * slide off handler
     * @param {Node|HTMLElement|EventTarget|Window} dragger
     * @param {Node|HTMLElement|EventTarget|Window} slide
     * @param {Event} e
     */

  }, {
    key: "eventSlideOffHandler",
    value: function eventSlideOffHandler(dragger, slide, e) {
      var self = this; // handler

      if (slide === e.target) {
        // @FIX on.xt and off.xt event bubbles
        self.eventSlideOff(dragger, e);
      }
    }
    /**
     * element drag on handler
     * @param {Node|HTMLElement|EventTarget|Window} dragger
     * @param {Event} e
     */

  }, {
    key: "eventDragstartHandler",
    value: function eventDragstartHandler(dragger, e) {
      var self = this; // handler

      if (!e.button || e.button !== 2) {
        // not right click or it gets stuck
        if (self.initial || !self.checkAnim(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].arrSingle(dragger))) {
          // logic
          var eventLimit = self.object.querySelectorAll('.event-limit');

          if (eventLimit.length) {
            if (!xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].checkNested(e.target, eventLimit)) {
              self.eventDragstart(dragger, e);
            }
          } else {
            self.eventDragstart(dragger, e);
          } // drag end


          var dragendHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(dragger, 'mouseup touchend' + '.' + self.namespace, self.eventDragendHandler.bind(self).bind(self, dragger));
          var events = ['mouseup', 'touchend'];

          for (var _i3 = 0, _events2 = events; _i3 < _events2.length; _i3++) {
            var event = _events2[_i3];
            addEventListener(event, dragendHandler);
          }
        }
      }
    }
    /**
     * element drag off handler
     * @param {Node|HTMLElement|EventTarget|Window} dragger
     * @param {Event} e
     */

  }, {
    key: "eventDragendHandler",
    value: function eventDragendHandler(dragger, e) {
      var self = this; // logic

      var eventLimit = self.object.querySelectorAll('.event-limit');

      if (eventLimit.length) {
        if (!xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].checkNested(e.target, eventLimit)) {
          self.eventDragend(dragger, e);
        }
      } else {
        self.eventDragend(dragger, e);
      }
    }
    /**
     * element drag on
     * @param {Node|HTMLElement|EventTarget|Window} dragger
     * @param {Event} e
     */

  }, {
    key: "eventDragstart",
    value: function eventDragstart(dragger, e) {
      var self = this; // event move

      var dragHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(dragger, 'mousemove touchmove' + '.' + self.namespace, self.eventDragHandler.bind(self).bind(self, dragger));
      var events = ['mousemove', 'touchmove'];

      for (var _i4 = 0, _events3 = events; _i4 < _events3.length; _i4++) {
        var event = _events3[_i4];
        dragger.addEventListener(event, dragHandler);
      } // logic


      self.logicDragstart(dragger, e);
    }
    /**
     * element drag off
     * @param {Node|HTMLElement|EventTarget|Window} dragger
     * @param {Event} e
     */

  }, {
    key: "eventDragend",
    value: function eventDragend(dragger, e) {
      var self = this; // event off

      var dragendHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(dragger, 'mouseup touchend' + '.' + self.namespace);
      var eventsoff = ['mouseup', 'touchend'];

      for (var _i5 = 0, _eventsoff = eventsoff; _i5 < _eventsoff.length; _i5++) {
        var event = _eventsoff[_i5];
        removeEventListener(event, dragendHandler);
      } // event move


      var dragHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(dragger, 'mousemove touchmove' + '.' + self.namespace);
      var eventsmove = ['mousemove', 'touchmove'];

      for (var _i6 = 0, _eventsmove = eventsmove; _i6 < _eventsmove.length; _i6++) {
        var _event = _eventsmove[_i6];
        dragger.removeEventListener(_event, dragHandler);
      } // logic


      self.logicDragend(dragger, e);
    }
    /**
     * element drag handler
     * @param {Node|HTMLElement|EventTarget|Window} dragger
     * @param {Event} e
     */

  }, {
    key: "eventDragHandler",
    value: function eventDragHandler(dragger, e) {
      var self = this; // logic

      self.logicDrag(dragger, e);
    }
    /**
     * resize
     * @param {Event} e
     */

  }, {
    key: "eventResizeHandler",
    value: function eventResizeHandler(e) {
      var self = this; // reinit

      if (!self.initial) {
        xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].eventDelay(e, self.object, function () {
          self.initLogic();
        }, self.componentNamespace + 'Resize');
      }
    } //
    // event
    //

    /**
     * slide on
     * @param {Node|HTMLElement|EventTarget|Window} dragger
     * @param {Event} e
     */

  }, {
    key: "eventSlideOn",
    value: function eventSlideOn(dragger, e) {
      var self = this;
      var options = self.options;
      var slide = e.target; // only one call per group

      if (xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(slide, self.componentNamespace + 'SlideOnDone')) {
        return;
      }

      var targets = self.getTargets(slide);
      var _iteratorNormalCompletion25 = true;
      var _didIteratorError25 = false;
      var _iteratorError25 = undefined;

      try {
        for (var _iterator25 = targets[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
          var target = _step25.value;
          xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(target, self.componentNamespace + 'SlideOnDone', true);
        } // autoHeight

      } catch (err) {
        _didIteratorError25 = true;
        _iteratorError25 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion25 && _iterator25.return != null) {
            _iterator25.return();
          }
        } finally {
          if (_didIteratorError25) {
            throw _iteratorError25;
          }
        }
      }

      if (self.autoHeight) {
        var slideHeight = slide.children[0].offsetHeight;
        var groupHeight = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(slide, self.componentNamespace + 'GroupHeight');
        slideHeight = groupHeight > slideHeight ? groupHeight : slideHeight;
        slideHeight += 'px';

        if (self.autoHeight.style.height !== slideHeight) {
          self.autoHeight.style.height = slideHeight; // listener dispatch

          var detail = self.eDetailSet();
          slide.dispatchEvent(new CustomEvent('autoHeight.xt', {
            bubbles: true,
            detail: detail
          }));
        }
      } // val


      self.detail.xPos = self.detail.xPosCurrent = self.detail.xPosReal = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(slide, self.componentNamespace + 'GroupPos'); // dragger

      if (dragger) {
        // prevent alignment animation
        dragger.classList.remove('duration-none'); // initial or resizing

        if (self.initial) {
          // prevent alignment animation
          dragger.classList.add('duration-none');
          requestAnimationFrame(function () {
            dragger.classList.remove('duration-none');
          });
        } // drag position


        dragger.style.transform = 'translateX(' + self.detail.xPos + 'px)'; // disable dragger

        dragger.classList.add('pointer-events--none');
        var _iteratorNormalCompletion26 = true;
        var _didIteratorError26 = false;
        var _iteratorError26 = undefined;

        try {
          for (var _iterator26 = self.navs[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
            var nav = _step26.value;
            nav.classList.add('pointer-events--none');
          }
        } catch (err) {
          _didIteratorError26 = true;
          _iteratorError26 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion26 && _iterator26.return != null) {
              _iterator26.return();
            }
          } finally {
            if (_didIteratorError26) {
              throw _iteratorError26;
            }
          }
        }

        xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].animTimeout(dragger, function () {
          dragger.classList.remove('pointer-events--none');
          var _iteratorNormalCompletion27 = true;
          var _didIteratorError27 = false;
          var _iteratorError27 = undefined;

          try {
            for (var _iterator27 = self.navs[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
              var nav = _step27.value;
              nav.classList.remove('pointer-events--none');
            }
          } catch (err) {
            _didIteratorError27 = true;
            _iteratorError27 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion27 && _iterator27.return != null) {
                _iterator27.return();
              }
            } finally {
              if (_didIteratorError27) {
                throw _iteratorError27;
              }
            }
          }
        }); // disable links

        dragger.classList.remove('jumps--none');
        dragger.classList.remove('links--none'); // drag wrap

        if (self.dragger && options.drag.wrap) {
          var min = self.groupMqFirst.length;
          var max = self.groupMqFirst.length + self.groupMqInitial.length - 1;

          if (self.initial) {
            // @FIX initial activation
            if (self.currentIndex < min) {
              requestAnimationFrame(function () {
                self.initial = true;
                self.goToIndex(min, true);
                self.initialCurrents = self.getCurrents().slice(0); // @FIX initialCurrents
              });
            }
          } else {
            // @FIX wrap with initial
            xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].animTimeout(dragger, function () {
              if (!self.initial) {
                if (self.currentIndex < min) {
                  self.initial = true;
                  self.goToIndex(max + self.currentIndex - min + 1, true); // wrap around xt-wrap items
                } else if (self.currentIndex > max) {
                  self.initial = true;
                  self.goToIndex(min + self.currentIndex - max - 1, true); // wrap around xt-wrap items
                }
              }
            }, 'wrap');
          }
        }
      } // disable links not active slide


      if (options.jump) {
        slide.classList.remove('links--none');
      }
    }
    /**
     * slide off
     * @param {Node|HTMLElement|EventTarget|Window} dragger
     * @param {Event} e
     */

  }, {
    key: "eventSlideOff",
    value: function eventSlideOff(dragger, e) {
      var self = this;
      var options = self.options;
      var slide = e.target; // disable links not active slide

      if (options.jump) {
        slide.classList.add('links--none');
      } // only one call per group


      var targets = self.getTargets(slide);
      var _iteratorNormalCompletion28 = true;
      var _didIteratorError28 = false;
      var _iteratorError28 = undefined;

      try {
        for (var _iterator28 = targets[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
          var target = _step28.value;
          xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.remove(target, self.componentNamespace + 'SlideOnDone');
        }
      } catch (err) {
        _didIteratorError28 = true;
        _iteratorError28 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion28 && _iterator28.return != null) {
            _iterator28.return();
          }
        } finally {
          if (_didIteratorError28) {
            throw _iteratorError28;
          }
        }
      }
    } //
    // logic
    //

    /**
     * element drag on logic
     * @param {Node|HTMLElement|EventTarget|Window} dragger
     * @param {Event} e
     */

  }, {
    key: "logicDragstart",
    value: function logicDragstart(dragger, e) {
      var self = this; // disabled

      if (self.disabled && !self.initial) {
        return;
      } // save event


      if (e.detail.wheelX !== undefined) {
        self.detail.xStart = e.detail.wheelX;
      } else if (e.clientX !== undefined) {
        self.detail.xStart = e.clientX;
      } else if (e.touches && e.touches.length) {
        self.detail.xStart = e.touches[0].clientX;
      } // auto


      self.eventAutoPause(); // prevent dragging animation

      dragger.classList.add('duration-none'); // logic

      self.detail.xVelocity = null;
      self.detail.xVelocityNext = null; // listener dispatch

      if (!self.initial) {
        var detail = self.eDetailSet(e);
        dragger.dispatchEvent(new CustomEvent('dragstart.xt.slider', {
          detail: detail
        }));
      }
    }
    /**
     * element drag off logic
     * @param {Node|HTMLElement|EventTarget|Window} dragger
     * @param {Event} e
     */

  }, {
    key: "logicDragend",
    value: function logicDragend(dragger, e) {
      var self = this; // disabled

      if (self.disabled && !self.initial) {
        return;
      } // save event


      if (e.detail.wheelX !== undefined) {
        self.detail.xCurrent = e.detail.wheelX;
      } else if (e.clientX !== undefined) {
        self.detail.xCurrent = e.clientX;
      } else if (e.touches && e.touches.length) {
        self.detail.xCurrent = e.touches[0].clientX;
      } // auto


      self.eventAutoStart(); // logic

      self.logicDragfriction(dragger, e); // listener dispatch

      if (!self.initial) {
        var detail = self.eDetailSet(e);
        dragger.dispatchEvent(new CustomEvent('dragend.xt.slider', {
          detail: detail
        }));
      }
    }
    /**
     * element drag friction logic
     * @param {Node|HTMLElement|EventTarget|Window} dragger
     * @param {Event} e
     */

  }, {
    key: "logicDragfriction",
    value: function logicDragfriction(dragger, e) {
      var self = this;
      var options = self.options; // friction

      if (Math.abs(self.detail.xVelocity) > options.drag.frictionLimit) {
        // disable dragger
        dragger.classList.add('pointer-events--none');
        var _iteratorNormalCompletion29 = true;
        var _didIteratorError29 = false;
        var _iteratorError29 = undefined;

        try {
          for (var _iterator29 = self.navs[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
            var nav = _step29.value;
            nav.classList.add('pointer-events--none');
          } // drag

        } catch (err) {
          _didIteratorError29 = true;
          _iteratorError29 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion29 && _iterator29.return != null) {
              _iterator29.return();
            }
          } finally {
            if (_didIteratorError29) {
              throw _iteratorError29;
            }
          }
        }

        self.logicDrag(dragger, e, true); // loop

        requestAnimationFrame(function () {
          self.logicDragfriction(dragger, e);
        });
      } else {
        // disable links
        dragger.classList.remove('links--none');
        dragger.classList.remove('jumps--none'); // dragend

        requestAnimationFrame(self.logicDragfrictionend.bind(self).bind(e, dragger));
      }
    }
    /**
     * element drag logic
     * @param {Node|HTMLElement|EventTarget|Window} dragger
     * @param {Event} e
     * @param {Boolean} friction
     */

  }, {
    key: "logicDrag",
    value: function logicDrag(dragger, e) {
      var friction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var self = this;
      var options = self.options; // disabled

      if (self.disabled && !self.initial) {
        return;
      } // save event


      if (e.detail.wheelX !== undefined) {
        self.detail.xCurrent = e.detail.wheelX;
      } else if (e.clientX !== undefined) {
        self.detail.xCurrent = e.clientX;
      } else if (e.touches && e.touches.length) {
        self.detail.xCurrent = e.touches[0].clientX;
      } // calculate


      var xPos = self.detail.xPosReal;
      var xPosCurrent = self.detail.xPosCurrent || 0;
      var sign = Math.sign(self.detail.xVelocity);

      if (friction && options.drag.friction) {
        // momentum
        var fncFriction = options.drag.friction;
        self.detail.xVelocity = fncFriction(Math.abs(self.detail.xVelocity)) * sign; // no momentum when stopping

        if (self.detail.dragDate) {
          var dateDiff = new Date() - self.detail.dragDate;
          self.detail.dragDate = null;

          if (dateDiff > options.drag.timeLimit) {
            self.detail.xVelocity = 0;
          }
        } // on friction


        xPos = xPos + self.detail.xVelocity;
        self.detail.xCurrent = xPos + self.detail.xStart - xPosCurrent;
      } else {
        // momentum
        self.detail.dragDate = new Date(); // on normal drag

        var xPosOld = xPos || 0;
        xPos = xPosCurrent + (self.detail.xCurrent - self.detail.xStart) * options.drag.factor; // keep some velocity (median value of previous frame and not current frame)

        self.detail.xVelocity = (self.detail.xVelocity + self.detail.xVelocityNext) / 2;
        self.detail.xVelocityNext = xPos - xPosOld;
      } // val


      self.detail.xPosReal = xPos;
      self.detail.xCurrentReal = self.detail.xCurrent; // check

      var xDist = xPos - xPosCurrent;

      if (Math.abs(xDist) > options.drag.linkThreshold) {
        // disable links
        dragger.classList.add('links--none');
        dragger.classList.add('jumps--none');
      } // overflow


      if (options.drag.overflow) {
        var arr = self.targets.filter(function (x) {
          return !x.classList.contains('xt-wrap');
        });
        var first = arr[0];
        var last = arr[arr.length - 1];
        var min = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(first, self.componentNamespace + 'GroupPos');
        var max = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(last, self.componentNamespace + 'GroupPos'); // overflow

        var fncOverflow = options.drag.overflow;

        if (friction && options.drag.friction) {
          if (xPos > min || xPos < max) {
            self.detail.xVelocity = fncOverflow(Math.abs(self.detail.xVelocity)) * sign;
          }
        } else {
          if (xPos > min) {
            self.detail.xVelocity = 0;
            var overflow = xPos - min;
            xPos = min + fncOverflow(overflow);
          } else if (xPos < max) {
            self.detail.xVelocity = 0;

            var _overflow = xPos - max;

            xPos = max - fncOverflow(-_overflow);
          }
        }
      } // val


      self.detail.xCurrent = self.detail.xCurrentReal - (self.detail.xPosReal - xPos); // xCurrent when overflowing

      self.detail.xPosOld = self.detail.xPos;
      self.detail.xPos = xPos; // drag position

      if (self.initial) {
        self.dragger.classList.add('transition-none');
      }

      if (options.drag.drag) {
        dragger.style.transform = 'translateX(' + self.detail.xPos + 'px)';
      }

      if (self.initial) {
        self.dragger.classList.remove('transition-none');
      } // listener dispatch


      if (!self.initial) {
        var detail = self.eDetailSet(e);
        dragger.dispatchEvent(new CustomEvent('drag.xt.slider', {
          detail: detail
        }));
      }
    }
    /**
     * element drag friction off logic
     * @param {Node|HTMLElement|EventTarget|Window} dragger
     * @param {Event} e
     */

  }, {
    key: "logicDragfrictionend",
    value: function logicDragfrictionend(dragger, e) {
      var self = this;
      var options = self.options;
      var xPosCurrent = self.detail.xPosCurrent || 0; // prevent dragging animation

      dragger.classList.remove('duration-none'); // only one call per group

      var currents = self.getCurrents();
      var _iteratorNormalCompletion30 = true;
      var _didIteratorError30 = false;
      var _iteratorError30 = undefined;

      try {
        for (var _iterator30 = currents[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
          var current = _step30.value;
          var _iteratorNormalCompletion34 = true;
          var _didIteratorError34 = false;
          var _iteratorError34 = undefined;

          try {
            for (var _iterator34 = self.getTargets(current)[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {
              var target = _step34.value;
              xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.remove(target, self.componentNamespace + 'SlideOnDone');
            }
          } catch (err) {
            _didIteratorError34 = true;
            _iteratorError34 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion34 && _iterator34.return != null) {
                _iterator34.return();
              }
            } finally {
              if (_didIteratorError34) {
                throw _iteratorError34;
              }
            }
          }
        } // activate or reset

      } catch (err) {
        _didIteratorError30 = true;
        _iteratorError30 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion30 && _iterator30.return != null) {
            _iterator30.return();
          }
        } finally {
          if (_didIteratorError30) {
            throw _iteratorError30;
          }
        }
      }

      var draggerWidth = self.dragger.offsetWidth;
      var xDist = self.detail.xPosReal - xPosCurrent;

      if (Math.abs(xDist) > options.drag.threshold) {
        // get nearest
        var found = self.currentIndex;
        var _iteratorNormalCompletion31 = true;
        var _didIteratorError31 = false;
        var _iteratorError31 = undefined;

        try {
          for (var _iterator31 = self.groupMq.entries()[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {
            var _step31$value = _slicedToArray(_step31.value, 2),
                i = _step31$value[0],
                group = _step31$value[1];

            var _iteratorNormalCompletion32 = true;
            var _didIteratorError32 = false;
            var _iteratorError32 = undefined;

            try {
              for (var _iterator32 = group[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
                var slideCheck = _step32.value;
                var check = void 0;

                if (options.align === 'center') {
                  check = self.detail.xPos - draggerWidth / 2 + slideCheck.offsetLeft;
                } else if (options.align === 'left') {
                  check = self.detail.xPos + slideCheck.offsetLeft;
                } else if (options.align === 'right') {
                  check = self.detail.xPos - draggerWidth + slideCheck.offsetLeft + slideCheck.offsetWidth;
                }

                if (check < 0 && xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].visible(slideCheck)) {
                  found = i;
                }
              }
            } catch (err) {
              _didIteratorError32 = true;
              _iteratorError32 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion32 && _iterator32.return != null) {
                  _iterator32.return();
                }
              } finally {
                if (_didIteratorError32) {
                  throw _iteratorError32;
                }
              }
            }
          } // goTo with force

        } catch (err) {
          _didIteratorError31 = true;
          _iteratorError31 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion31 && _iterator31.return != null) {
              _iterator31.return();
            }
          } finally {
            if (_didIteratorError31) {
              throw _iteratorError31;
            }
          }
        }

        if (found === self.currentIndex) {
          // change at least one
          if (Math.sign(xDist) < 0) {
            self.goToNext(1, true);
          } else {
            self.goToPrev(1, true);
          }
        } else {
          // goToIndex
          self.goToIndex(found, true);
        }
      } else {
        // val
        self.detail.xPosOld = self.detail.xPos;
        self.detail.xPos = self.detail.xPosCurrent; // disable drag and links

        xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].animTimeout(dragger, function () {
          // disable dragger
          dragger.classList.remove('pointer-events--none');
          var _iteratorNormalCompletion33 = true;
          var _didIteratorError33 = false;
          var _iteratorError33 = undefined;

          try {
            for (var _iterator33 = self.navs[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {
              var nav = _step33.value;
              nav.classList.remove('pointer-events--none');
            }
          } catch (err) {
            _didIteratorError33 = true;
            _iteratorError33 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion33 && _iterator33.return != null) {
                _iterator33.return();
              }
            } finally {
              if (_didIteratorError33) {
                throw _iteratorError33;
              }
            }
          }
        }); // drag position

        if (self.initial) {
          self.dragger.classList.add('transition-none');
        }

        dragger.style.transform = 'translateX(' + self.detail.xPosCurrent + 'px)';

        if (self.initial) {
          self.dragger.classList.remove('transition-none');
        } // listener dispatch


        if (!self.initial) {
          var detail = self.eDetailSet(e);
          dragger.dispatchEvent(new CustomEvent('dragreset.xt.slider', {
            detail: detail
          }));
        }
      }
    }
  }]);

  return Slider;
}(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Toggle); //
// option
//


Slider.componentName = 'xt-slider';
Slider.optionsDefault = {
  elements: '[data-xt-pag]',
  targets: '.slide',
  on: 'click',
  min: 1,
  max: 1,
  instant: true,
  loop: true,
  jump: true,
  imageLoadedInit: true,
  navigation: '[data-xt-nav]',
  wheel: {
    selector: false,
    block: true,
    limit: false,
    transform: true,
    horizontal: true,
    factor: 1,
    friction: function friction(delta) {
      return delta / 9;
    },
    frictionLimit: 1.5
  },
  keyboard: {
    selector: '.slides'
  },
  aria: {
    labelledby: false
  },
  // slider only
  autoHeight: '.slides',
  groupMq: {
    all: 0.8
  },
  align: 'center',
  contain: false,
  pagination: '.slider_pagination',
  drag: {
    drag: true,
    wrap: false,
    dragger: '.slides_inner',
    threshold: 50,
    linkThreshold: 50,
    factor: 1,
    friction: function friction(velocity) {
      return Math.pow(velocity, 0.9);
    },
    frictionLimit: 1.5,
    overflow: function overflow(_overflow2) {
      return Math.pow(_overflow2, 0.73);
    },
    timeLimit: 25
  } //
  // export
  //

};
xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Slider = Slider; //
// observe
//

xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].mount.push({
  matches: '[data-' + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Slider.componentName + ']',
  mount: function mount(object) {
    // init
    var self = new xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Slider(object, object.getAttribute('data-' + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Slider.componentName)); // unmount

    return function unmount() {
      self.destroy();
      self = null;
    };
  }
});

/***/ }),

/***/ "./src/core/smooth/smooth.js":
/*!***********************************!*\
  !*** ./src/core/smooth/smooth.js ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var xtend_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xtend-library */ "./src/xt.js");
/* harmony import */ var xtend_library_src_core_toggle_toggle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xtend-library/src/core/toggle/toggle.js */ "./src/core/toggle/toggle.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var Smooth =
/*#__PURE__*/
function (_Xt$Toggle) {
  _inherits(Smooth, _Xt$Toggle);

  /**
   * constructor
   * @param {Node|HTMLElement|EventTarget|Window} object Base node
   * @param {Object} optionsJs User options
   * @constructor
   */
  function Smooth(object) {
    var optionsJs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Smooth);

    return _possibleConstructorReturn(this, _getPrototypeOf(Smooth).call(this, object, optionsJs));
  }

  return Smooth;
}(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Toggle); //
// option
//


Smooth.componentName = 'xt-smooth';
Smooth.optionsDefault = {
  class: false,
  wheel: {
    selector: 'scrollingElement',
    block: false,
    limit: true,
    transform: false,
    horizontal: false,
    factor: 1,
    friction: function friction(delta) {
      return delta / 9;
    },
    frictionLimit: 1.5
  } //
  // export
  //

};
xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Smooth = Smooth; //
// observe
//

xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].mount.push({
  matches: '[data-' + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Smooth.componentName + ']',
  mount: function mount(object) {
    // init
    var self = new xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Smooth(object, object.getAttribute('data-' + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Smooth.componentName)); // unmount

    return function unmount() {
      self.destroy();
      self = null;
    };
  }
});

/***/ }),

/***/ "./src/core/sticky/sticky.js":
/*!***********************************!*\
  !*** ./src/core/sticky/sticky.js ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var xtend_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xtend-library */ "./src/xt.js");
/* harmony import */ var xtend_library_src_core_toggle_toggle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xtend-library/src/core/toggle/toggle.js */ "./src/core/toggle/toggle.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var Sticky =
/*#__PURE__*/
function (_Xt$Toggle) {
  _inherits(Sticky, _Xt$Toggle);

  /**
   * constructor
   * @param {Node|HTMLElement|EventTarget|Window} object Base node
   * @param {Object} optionsJs User options
   * @constructor
   */
  function Sticky(object) {
    var optionsJs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Sticky);

    return _possibleConstructorReturn(this, _getPrototypeOf(Sticky).call(this, object, optionsJs));
  } //
  // init
  //

  /**
   * init elements, targets and currents
   */


  _createClass(Sticky, [{
    key: "initScope",
    value: function initScope() {
      _get(_getPrototypeOf(Sticky.prototype), "initScope", this).call(this);

      var self = this;
      var options = self.options; // mode

      self.mode = 'unique'; // sticky container

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = self.elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var el = _step.value;
          var container = el.closest('.xt-container');

          if (!container) {
            container = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].createElement('<div class="xt-container xt-fixed--check"></div>');
            el.before(container);
            el.classList.add('xt-ignore', 'xt-ignore--once'); // @FIX ignore once for mount when moving

            container.append(el);
          }

          el.style[options.position] = '0px'; // sticky clone

          var target = container.querySelector('.xt-clone');

          if (!target) {
            target = el.cloneNode(true);
            target.classList.add('xt-clone', 'xt-ignore');
            target.classList.remove('xt-ignore--once'); // @FIX ignore once for mount when moving

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = target.querySelectorAll('[id]')[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var elId = _step2.value;
                elId.setAttribute('id', elId.getAttribute('id') + '-clone');
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = target.querySelectorAll('[name]')[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var elName = _step3.value;
                elName.setAttribute('name', elName.getAttribute('name') + '-clone');
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            container.append(target);
          }

          self.targets.push(target); // sticky

          el.classList.add('xt-fixed', 'xt-sticky');

          if (options.sticky === 'absolute') {
            el.classList.add('xt-sticky--absolute');
          } else if (options.sticky === 'fixed') {
            el.classList.add('xt-sticky--fixed');
          } else if (options.sticky === 'fixed-always') {
            el.classList.add('xt-sticky--fixed-always');
          }

          if (target) {
            target.classList.add('xt-fixed', 'xt-sticky');

            if (options.sticky === 'absolute') {
              target.classList.add('xt-sticky--absolute');
            } else if (options.sticky === 'fixed') {
              target.classList.add('xt-sticky--fixed');
            } else if (options.sticky === 'fixed-always') {
              target.classList.add('xt-sticky--fixed-always');
            }
          } // hide


          if (options.hide === 'down') {
            el.classList.add('sticky-hide--down');
          } else {
            el.classList.remove('sticky-hide--down');
          }

          if (options.hide === 'up') {
            el.classList.add('sticky-hide--up');
          } else {
            el.classList.remove('sticky-hide--up');
          } // @index--sticky by javascript 100 and decreses with sequential sticky


          el.style.zIndex = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].getStickyIndex();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * init events
     */

  }, {
    key: "initEvents",
    value: function initEvents() {
      var self = this;
      var options = self.options; // event on

      if (options.on) {
        var stickyHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(window, options.on + '.' + self.namespace, self.eventStickyHandler.bind(self));

        var events = _toConsumableArray(options.on.split(' '));

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = events[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var event = _step4.value;
            addEventListener(event, stickyHandler, xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].passiveSupported ? {
              passive: true
            } : false);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        requestAnimationFrame(function () {
          self.eventStickyHandler(null, true);
        });
      } // autoClose


      var autoCloseHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(self.object, 'hide' + '.' + self.namespace, xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].autoClose.bind(self, self.object));
      self.object.addEventListener('hide.xt.sticky', autoCloseHandler); // focusin

      var focusInHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(document, 'focusin' + '.' + self.namespace, self.eventFocusInHandler.bind(self));
      document.addEventListener('focusin', focusInHandler, xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].passiveSupported ? {
        passive: true
      } : false);
    } //
    // handler
    //

    /**
     * element on handler
     * @param {Event} e
     * @param {Boolean} initial
     */

  }, {
    key: "eventStickyHandler",
    value: function eventStickyHandler() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var initial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var self = this; // handler

      if (!e || !e.detail || !e.detail.skip) {
        // @FIX filter triggered from library (use only in library)
        xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].eventDelay(e, self.object, function () {
          self.eventSticky(e, initial);
        }, self.componentNamespace + 'Resize');
      }
    }
    /**
     * element focusin handler
     * @param {Event} e
     */

  }, {
    key: "eventFocusInHandler",
    value: function eventFocusInHandler(e) {
      var self = this; // handler

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = self.targets[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var tr = _step5.value;
          var el = self.getElements(tr)[0]; // show element if is hiding on focus

          if (el.classList.contains('sticky--hide')) {
            var active = el.contains(e.target);

            if (active) {
              el.style.transform = 'translateY(0px)';
            } else {
              el.style.transform = 'translateY(' + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'AddOld') + 'px)';
            }
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    } //
    // event
    //

    /**
     * window scroll
     * @param {Event} e
     * @param {Boolean} initial
     */

  }, {
    key: "eventSticky",
    value: function eventSticky(e, initial) {
      var self = this;
      var options = self.options; // disabled

      if (self.disabled && !self.initial) {
        return;
      } // vars


      var anim = true;
      var hide = false;
      var add = 0;
      var addHide = 0;
      var windowHeight = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].windowHeight;
      var scrollingElement = document.scrollingElement;
      var scrollHeight = scrollingElement.scrollHeight;
      var scrollTop = scrollingElement.scrollTop; // direction

      self.detail.inverseForce = scrollTop < self.detail.scrollTopOld; // loop

      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = self.elements[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var el = _step6.value;
          var tr = self.getTargets(el)[0]; // vars

          var heightEl = parseFloat(getComputedStyle(el).height);
          var heightTr = parseFloat(getComputedStyle(tr).height);
          var topTr = tr.getBoundingClientRect().top; // hide

          if (options.hide === 'down') {
            if (!self.detail.inverseForce) {
              addHide = heightTr;
            }
          }

          if (options.hide === 'up') {
            if (self.detail.inverseForce) {
              addHide = heightTr;
            }
          } // scroll


          var top = self.eventStickyPos(options.limit.top || self.targets, scrollTop, topTr);
          var bottom = self.eventStickyPos(options.limit.bottom, scrollTop, Infinity);

          if (options.position === 'top') {
            bottom -= heightTr;
          }

          if (options.position === 'bottom') {
            top -= windowHeight - heightTr;
            bottom = Math.abs(scrollHeight - windowHeight - bottom);
          } // contain and add


          var addTop = 0;
          var addBottom = 0;

          if (options.contain) {
            if (options.contain.top) {
              var addTopObj = self.eventStickyHeight(options.contain.top);
              addTop = addTopObj.val;

              if (addTop !== null && addTop > topTr) {
                add = addTop;

                if (!addTopObj.foundHide) {
                  anim = false;
                }
              } else {
                addTop = null;
              }
            }

            if (options.contain.bottom) {
              addBottom = self.eventStickyPos(options.contain.bottom);

              if (addBottom !== null && addBottom < heightEl + addTop) {
                add = addBottom - heightEl;
                anim = false;
              } else {
                addBottom = null;
              }
            }
          } // save real add for calculation


          xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'Add', add); // activation

          var checkTop = scrollTop >= top - add + addHide;
          var checkBottom = scrollTop < bottom + add - addHide;

          if (checkTop && checkBottom) {
            // initial
            if (initial) {
              xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'Initial', true);
            } else {
              xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.remove(el, self.componentNamespace + 'Initial');
            } // inside


            self.eventOn(el, true); // hide

            if (addHide) {
              hide = true;
            }
          } else {
            // initial
            if (initial) {
              xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'Initial', true);
            } else {
              xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.remove(el, self.componentNamespace + 'Initial');
            } // outside


            self.eventOff(el, true);
          } // after active


          if (el.matches(self.classesMatch)) {
            // hide
            if (hide) {
              add = -heightEl;

              if (!el.classList.contains('sticky--hide')) {
                el.classList.add('sticky--hide'); // autoClose

                dispatchEvent(new CustomEvent('autoClose.xt')); // listener dispatch

                var _detail = self.eDetailSet(e);

                el.dispatchEvent(new CustomEvent('hide.xt.sticky', {
                  bubbles: true,
                  detail: _detail
                }));
              }
            } else {
              if (el.classList.contains('sticky--hide')) {
                el.classList.remove('sticky--hide'); // listener dispatch

                var _detail2 = self.eDetailSet(e);

                el.dispatchEvent(new CustomEvent('show.xt.sticky', {
                  bubbles: true,
                  detail: _detail2
                }));
              }
            }
          } else {
            // reset
            add = 0;
            anim = false;
          } // anim


          if (anim && (addTop || !addBottom) && self.detail.scrollTopOld !== undefined) {
            if (!el.classList.contains('sticky--moving')) {
              el.classList.add('sticky--moving');
            }
          } else {
            if (el.classList.contains('sticky--moving')) {
              el.classList.remove('sticky--moving');
            }
          } // top and bottom

          /*
          if (!checkTop) {
            if (!el.classList.contains('sticky--top')) {
              el.classList.add('sticky--top');
            }
          } else {
            if (el.classList.contains('sticky--top')) {
              el.classList.remove('sticky--top');
            }
          }
          if (!checkBottom) {
            if (!el.classList.contains('sticky--bottom')) {
              el.classList.add('sticky--bottom');
            }
          } else {
            if (el.classList.contains('sticky--bottom')) {
              el.classList.remove('sticky--bottom');
            }
          }
          */
          // set add


          if (add !== xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'AddOld')) {
            el.style.transform = 'translateY(' + add + 'px)';
          } // fix position fixed width 100% of parent


          var width = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].normalizeWidth(tr.clientWidth);

          if (el.style.width !== width) {
            el.style.width = width;
          } // dispatch


          var detail = self.eDetailSet();
          el.dispatchEvent(new CustomEvent('change.xt.sticky', {
            bubbles: true,
            detail: detail
          })); // save for direction

          xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'AddOld', add);
        } // save for direction

      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      self.detail.scrollTopOld = scrollTop;
    }
    /**
     * get position of option
     * @param {String|Number|Element} option
     * @param {Number} val Default value
     * @param {Number} scrollTop Window's scrollTop
     * @returns {Number} value Option's position (px)
     */

  }, {
    key: "eventStickyPos",
    value: function eventStickyPos(option) {
      var scrollTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var val = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (!isNaN(parseFloat(option))) {
        val = option;
      } else {
        var elements = Array.isArray(option) || option instanceof Element ? option : document.querySelectorAll(option);

        if (elements.length) {
          var found = false;
          val = 0;
          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = undefined;

          try {
            for (var _iterator7 = elements[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var el = _step7.value;
              var add = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'Add');

              if (add) {
                // if sticky--hide get real add
                var style = getComputedStyle(el);

                if (style.display !== 'none') {
                  val += add;
                  found = true;
                }
              } else {
                var rect = el.getBoundingClientRect();
                val += rect.top;
                found = true;
              }
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
                _iterator7.return();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }

          if (found) {
            val += scrollTop;
          } else {
            val = null;
          }
        }
      }

      return val;
    } //
    // event util
    //

    /**
     * get height of option
     * @param {String|Number|Element} option
     * @param {Number} val Default value
     * @returns {Object} obj Option's height (px) and if found hide element
     */

  }, {
    key: "eventStickyHeight",
    value: function eventStickyHeight(option) {
      var val = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var self = this; // logic

      var foundHide = false;

      if (!isNaN(parseFloat(option))) {
        val = option;
      } else {
        var elements = Array.isArray(option) || option instanceof Element ? option : document.querySelectorAll(option);

        if (elements.length) {
          var _iteratorNormalCompletion8 = true;
          var _didIteratorError8 = false;
          var _iteratorError8 = undefined;

          try {
            for (var _iterator8 = elements[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var el = _step8.value;

              if (el.classList.contains('sticky-hide--down') && el.matches(self.classesMatch)) {
                if (self.detail.inverseForce) {
                  val += el.clientHeight;
                  foundHide = true;
                }
              } else if (el.classList.contains('sticky-hide--up') && el.matches(self.classesMatch)) {
                if (!self.detail.inverseForce) {
                  val += el.clientHeight;
                  foundHide = true;
                }
              } else {
                val += el.clientHeight;
              }
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                _iterator8.return();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }
        }
      }

      return {
        val: val,
        foundHide: foundHide
      };
    }
  }]);

  return Sticky;
}(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Toggle); //
// option
//


Sticky.componentName = 'xt-sticky';
Sticky.optionsDefault = {
  elements: false,
  targets: false,
  on: 'scroll resize',
  min: 0,
  max: 'Infinity',
  instant: true,
  sticky: true,
  position: 'top',
  limit: {
    bottom: 'Infinity'
  },
  contain: false,
  hide: false,
  aria: false //
  // export
  //

};
xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Sticky = Sticky; //
// observe
//

xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].mount.push({
  matches: '[data-' + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Sticky.componentName + ']',
  mount: function mount(object) {
    // init
    var self = new xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Sticky(object, object.getAttribute('data-' + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Sticky.componentName)); // unmount

    return function unmount() {
      self.destroy();
      self = null;
    };
  }
});

/***/ }),

/***/ "./src/core/toggle/toggle.js":
/*!***********************************!*\
  !*** ./src/core/toggle/toggle.js ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var xtend_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xtend-library */ "./src/xt.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var Toggle =
/*#__PURE__*/
function () {
  /**
   * constructor
   * @param {Node|HTMLElement|EventTarget|Window} object Base node
   * @param {Object} optionsJs User options
   * @constructor
   */
  function Toggle(object) {
    var optionsJs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Toggle);

    var self = this;
    self.object = object;
    self.optionsJs = optionsJs;
    self.componentName = self.constructor.componentName;
    self.componentNamespace = self.componentName.replace(/^[^a-z]+|[ ,#_:.-]+/gi, '');
    xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].checkDefined(self, function () {
      self.init();
    });
  } //
  // init
  //

  /**
   * init
   */


  _createClass(Toggle, [{
    key: "init",
    value: function init() {
      var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var optionsJs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var self = this;
      self.object = object || self.object;
      self.optionsJs = optionsJs || self.optionsJs; // vars

      self.classes = [];
      self.classesIn = [];
      self.classesOut = [];
      self.classesInitial = [];
      self.classesInverse = [];
      self.elements = [];
      self.targets = [];
      self.currentIndex = null;
      self.initialCurrents = [];
      self.detail = {};
      self.disabled = false;
      self.detail.queueOn = [];
      self.detail.queueOff = [];
      self.detail.inverse = false;
      self.detail.autoPaused = false;
      self.destroyElements = [document, window, self.object]; // init

      self.initVars();
      self.initSetup();
      self.initLogic();
    }
    /**
     * init vars
     */

  }, {
    key: "initVars",
    value: function initVars() {
      var self = this; // option

      if (self.constructor.optionsDefaultSuper) {
        self.optionsDefault = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].merge([self.constructor.optionsDefaultSuper, self.constructor.optionsDefault]);
      } else {
        self.optionsDefault = self.constructor.optionsDefaultSuper;
      } // js options


      self.options = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].merge([self.optionsDefault, self.optionsJs]); // markup options

      var markupOptions = self.object.getAttribute('data-' + self.componentName);
      self.options = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].merge([self.options, markupOptions ? JSON.parse(markupOptions) : {}]); // classes

      self.classes = self.options.class ? _toConsumableArray(self.options.class.split(' ')) : [];
      self.classesIn = self.options.classIn ? _toConsumableArray(self.options.classIn.split(' ')) : [];
      self.classesOut = self.options.classOut ? _toConsumableArray(self.options.classOut.split(' ')) : [];
      self.classesInitial = self.options.classInitial ? _toConsumableArray(self.options.classInitial.split(' ')) : [];
      self.classesInverse = self.options.classInverse ? _toConsumableArray(self.options.classInverse.split(' ')) : [];
      self.classesMatch = self.classes.length ? '.' + self.classes.join('.') : false;
      self.classesInMatch = self.classesIn.length ? '.' + self.classesIn.join('.') : false;
      self.classesOutMatch = self.classesOut.length ? '.' + self.classesOut.join('.') : false;
      self.classesInitialMatch = self.classesInitial.length ? '.' + self.classesInitial.join('.') : false;
      self.classesInverseMatch = self.classesInverse.length ? '.' + self.classesInverse.join('.') : false;
    }
    /**
     * init setup
     */

  }, {
    key: "initSetup",
    value: function initSetup() {
      var self = this;
      var options = self.options; // setup (based on xtend mode)

      if (options.targets && options.targets.indexOf('#') !== -1) {
        // xtend unique mode
        self.mode = 'unique';
        self.container = document.documentElement;
        options.max = Infinity;
        self.namespace = self.componentName + '-' + options.targets.toString() + '-' + self.classes.toString();
      } else {
        // xtend multiple mode
        self.mode = 'multiple';
        self.container = self.object;
        var uniqueId = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(self.container, 'xtUniqueId');
        xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(self.container, 'xtUniqueId', uniqueId || xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].getuniqueId());
        self.namespace = self.componentName + '-' + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(self.container, 'xtUniqueId');
      } // final namespace


      self.namespace = self.namespace.replace(/^[^a-z]+|[ ,#_:.-]+/gi, ''); // currents array based on namespace (so shared between Xt objects)

      self.setCurrents([]);
    }
    /**
     * init logic
     */

  }, {
    key: "initLogic",
    value: function initLogic() {
      var self = this;
      self.initScope();
      self.initAria();
      self.initStart(true);
    }
    /**
     * init elements, targets and currents
     */

  }, {
    key: "initScope",
    value: function initScope() {
      var self = this; // elements

      self.initScopeElements(); // targets

      self.initScopeTargets();
    }
    /**
     * init elements
     */

  }, {
    key: "initScopeElements",
    value: function initScopeElements() {
      var self = this;
      var options = self.options; // elements

      if (options.elements) {
        var _self$destroyElements;

        var arr = Array.from(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].arrSingle(self.container.querySelectorAll(options.elements)));
        arr = arr.filter(function (x) {
          return !x.closest('.xt-ignore');
        }); // filter out ignore

        self.elements = arr;

        (_self$destroyElements = self.destroyElements).push.apply(_self$destroyElements, _toConsumableArray(self.elements));
      }

      if (!self.elements.length) {
        self.elements = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].arrSingle(self.object); // @FIX set namespace for next frame

        requestAnimationFrame(function () {
          var arr = Array.from(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].arrSingle(document.querySelectorAll('[data-xt-namespace=' + self.namespace + ']')));
          arr = arr.filter(function (x) {
            return !x.closest('.xt-ignore');
          }); // filter out ignore

          if (arr.length) {
            var _self$destroyElements2;

            // fix when using shadow dom doesn't query deep
            self.elements = arr;

            (_self$destroyElements2 = self.destroyElements).push.apply(_self$destroyElements2, _toConsumableArray(self.elements));
          }
        });
      }
    }
    /**
     * init targets
     */

  }, {
    key: "initScopeTargets",
    value: function initScopeTargets() {
      var self = this;
      var options = self.options; // targets

      if (options.targets) {
        var _self$destroyElements3;

        var arr = Array.from(self.container.querySelectorAll(options.targets)); // arr = arr.filter(x => !x.parentElement.closest(options.targets)); // filter out parent

        arr = arr.filter(function (x) {
          return !x.closest('.xt-ignore');
        }); // filter out ignore

        self.targets = arr;

        (_self$destroyElements3 = self.destroyElements).push.apply(_self$destroyElements3, _toConsumableArray(self.targets));
      }
    }
    /**
     * init start
     * @param {Boolean} saveCurrents
     */

  }, {
    key: "initStart",
    value: function initStart() {
      var saveCurrents = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var self = this;
      var options = self.options; // initial

      var currents = 0;
      self.initial = true;
      self.currentIndex = null; // @FIX set namespace for next frame

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = self.elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var el = _step.value;
          el.setAttribute('data-xt-namespace', self.namespace);
        } // automatic initial currents

      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var elements = self.getGroups();

      if (elements.length) {
        // check elements
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          var _loop = function _loop() {
            var element = _step2.value;
            // reset
            var found = self.initReset(element, saveCurrents);

            if (found) {
              // initial
              currents++; // reactivate

              requestAnimationFrame(function () {
                // activate
                self.eventOn(element, true);
              });
            }
          };

          for (var _iterator2 = elements[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            _loop();
          } // if currents < min

        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var todo = options.min - currents;

        if (todo > 0) {
          var start = 0;

          if (!self.disabled && self.dragger && options.drag.wrap) {
            start = 1;
            todo += start;
          } // initial


          currents++; // activate

          requestAnimationFrame(function () {
            for (var i = start; i < todo; i++) {
              self.eventOn(self.elements[i], true);
            }
          });
        } // initial


        self.setCurrents([]);

        if (saveCurrents) {
          requestAnimationFrame(function () {
            self.initialCurrents = self.getCurrents().slice(0);
          });
        }

        if (currents === 0) {
          self.initial = false;

          if (options.auto && options.auto.initial) {
            self.eventAutoStart();
          }
        }
      } // init events


      self.initEvents(); // listener dispatch

      requestAnimationFrame(function () {
        var detail = self.eDetailSet();
        self.object.dispatchEvent(new CustomEvent('init.xt', {
          detail: detail
        }));
      });
    }
    /**
     * init reset element activation
     * @param {Node|HTMLElement|EventTarget|Window} el Element to check and reset
     * @returns {Boolean} if element was activated
     * @param {Boolean} saveCurrents
     */

  }, {
    key: "initReset",
    value: function initReset(el) {
      var saveCurrents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var self = this;
      var found = false; // reset

      var reset = function reset(elReset) {
        if (elReset.matches(self.classesMatch)) {
          var _elReset$classList;

          (_elReset$classList = elReset.classList).remove.apply(_elReset$classList, _toConsumableArray(self.classes).concat(_toConsumableArray(self.classesIn), _toConsumableArray(self.classesOut), _toConsumableArray(self.classesInitial), _toConsumableArray(self.classesInverse)));

          xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.remove(elReset, self.componentNamespace + 'Initial');

          if (saveCurrents) {
            found = true;
          } // listener dispatch


          var detail = self.eDetailSet();
          elReset.dispatchEvent(new CustomEvent('off.xt', {
            bubbles: true,
            detail: detail
          }));
        }

        return found;
      }; // elements


      var group = el.getAttribute('data-xt-group');

      if (group) {
        var groupEls = Array.from(self.elements).filter(function (x) {
          return x.getAttribute('data-xt-group') === group;
        });
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = groupEls[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var groupEl = _step3.value;
            found = reset(groupEl);

            if (!saveCurrents && self.initialCurrents.includes(groupEl)) {
              found = true;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      } else {
        found = reset(el);

        if (!saveCurrents && self.initialCurrents.includes(el)) {
          found = true;
        }
      } // targets


      var targets = self.getTargets(el);
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = targets[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var tr = _step4.value;
          found = reset(tr);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return found;
    }
    /**
     * init aria
     */

  }, {
    key: "initAria",
    value: function initAria() {
      var self = this;
      var options = self.options; // role

      self.initAriaRole(); // aria

      if (options.aria) {
        if (self.targets.length) {
          // elements
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = self.elements[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var _el = _step5.value;

              var _ariaEls = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].queryAll(_el, options.ariaControls);

              var _ariaEl = _ariaEls.length ? _ariaEls[0] : _el; // id


              if (options.aria === true || options.aria.labelledby || options.aria.controls) {
                var id = _ariaEl.getAttribute('id');

                if (!id) {
                  _ariaEl.setAttribute('id', xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].getuniqueId());
                }
              } // selected


              _ariaEl.setAttribute('aria-selected', 'false');
            } // targets

          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }

          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = self.targets[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var _tr = _step6.value;
              var els = self.getTargets(_tr); // expanded

              var role = _tr.getAttribute('role');

              if (role === 'tabpanel' || role === 'listbox' || role === 'dialog') {
                _tr.setAttribute('aria-expanded', 'false');
              } // tabindex


              if (options.aria === true || options.aria.tabindex) {
                var focusables = _tr.querySelectorAll(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].focusables);

                var _iteratorNormalCompletion9 = true;
                var _didIteratorError9 = false;
                var _iteratorError9 = undefined;

                try {
                  for (var _iterator9 = focusables[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                    var focusable = _step9.value;
                    focusable.setAttribute('tabindex', '-1');
                  }
                } catch (err) {
                  _didIteratorError9 = true;
                  _iteratorError9 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
                      _iterator9.return();
                    }
                  } finally {
                    if (_didIteratorError9) {
                      throw _iteratorError9;
                    }
                  }
                }
              } // id


              if (options.aria === true || options.aria.labelledby || options.aria.controls) {
                var _id = _tr.getAttribute('id');

                if (!_id) {
                  _tr.setAttribute('id', xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].getuniqueId());
                }
              } // labelledby


              if (options.aria === true || options.aria.labelledby) {
                var _str = ' ';
                _str += _tr.getAttribute('aria-labelledby') || '';
                var _iteratorNormalCompletion10 = true;
                var _didIteratorError10 = false;
                var _iteratorError10 = undefined;

                try {
                  for (var _iterator10 = els[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                    var _el2 = _step10.value;

                    var _ariaEls2 = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].queryAll(_el2, options.ariaControls);

                    var _ariaEl2 = _ariaEls2.length ? _ariaEls2[0] : _el2;

                    _str += ' ' + _ariaEl2.getAttribute('id');
                  }
                } catch (err) {
                  _didIteratorError10 = true;
                  _iteratorError10 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
                      _iterator10.return();
                    }
                  } finally {
                    if (_didIteratorError10) {
                      throw _iteratorError10;
                    }
                  }
                }

                _tr.setAttribute('aria-labelledby', _str.trim());
              }
            } // ariaControls

          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
                _iterator6.return();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }

          if (options.aria === true || options.aria.controls) {
            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
              for (var _iterator7 = self.elements[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var el = _step7.value;
                var trs = self.getTargets(el);
                var ariaEls = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].queryAll(el, options.ariaControls);
                var ariaEl = ariaEls.length ? ariaEls[0] : el; // controls

                var str = ' ';
                str += ariaEl.getAttribute('aria-controls') || '';
                var _iteratorNormalCompletion8 = true;
                var _didIteratorError8 = false;
                var _iteratorError8 = undefined;

                try {
                  for (var _iterator8 = trs[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                    var tr = _step8.value;
                    str += ' ' + tr.getAttribute('id');
                  }
                } catch (err) {
                  _didIteratorError8 = true;
                  _iteratorError8 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                      _iterator8.return();
                    }
                  } finally {
                    if (_didIteratorError8) {
                      throw _iteratorError8;
                    }
                  }
                }

                ariaEl.setAttribute('aria-controls', str.trim());
              }
            } catch (err) {
              _didIteratorError7 = true;
              _iteratorError7 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
                  _iterator7.return();
                }
              } finally {
                if (_didIteratorError7) {
                  throw _iteratorError7;
                }
              }
            }
          }
        }
      }
    }
    /**
     * init aria role
     */

  }, {
    key: "initAriaRole",
    value: function initAriaRole() {
      var self = this;
      var options = self.options; // aria

      if (options.aria) {
        if (self.targets.length) {
          // role
          if (self.mode === 'multiple') {
            self.object.setAttribute('role', 'tablist');

            if (options.max > 1) {
              self.object.setAttribute('aria-multiselectable', 'true');
            }

            var _iteratorNormalCompletion11 = true;
            var _didIteratorError11 = false;
            var _iteratorError11 = undefined;

            try {
              for (var _iterator11 = self.elements[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                var el = _step11.value;
                var ariaEls = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].queryAll(el, options.ariaControls);
                var ariaEl = ariaEls.length ? ariaEls[0] : el;
                ariaEl.setAttribute('role', 'tab');
              }
            } catch (err) {
              _didIteratorError11 = true;
              _iteratorError11 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
                  _iterator11.return();
                }
              } finally {
                if (_didIteratorError11) {
                  throw _iteratorError11;
                }
              }
            }

            var _iteratorNormalCompletion12 = true;
            var _didIteratorError12 = false;
            var _iteratorError12 = undefined;

            try {
              for (var _iterator12 = self.targets[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                var tr = _step12.value;
                tr.setAttribute('role', 'tabpanel');
              }
            } catch (err) {
              _didIteratorError12 = true;
              _iteratorError12 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                  _iterator12.return();
                }
              } finally {
                if (_didIteratorError12) {
                  throw _iteratorError12;
                }
              }
            }
          }
        }
      }
    }
    /**
     * init events
     */

  }, {
    key: "initEvents",
    value: function initEvents() {
      var self = this;
      var options = self.options; // status

      var checkHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(window, 'resize.check' + '.' + self.namespace, self.eventStatusHandler.bind(self).bind(self));
      addEventListener('resize', checkHandler);
      self.eventStatusHandler(); // event

      var _iteratorNormalCompletion13 = true;
      var _didIteratorError13 = false;
      var _iteratorError13 = undefined;

      try {
        for (var _iterator13 = self.elements[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
          var _el3 = _step13.value;

          // event on
          if (options.on) {
            var onHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(_el3, options.on + '.' + self.namespace, self.eventOnHandler.bind(self).bind(self, _el3));

            var events = _toConsumableArray(options.on.split(' '));

            var _iteratorNormalCompletion21 = true;
            var _didIteratorError21 = false;
            var _iteratorError21 = undefined;

            try {
              for (var _iterator21 = events[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
                var _event2 = _step21.value;

                _el3.addEventListener(_event2, onHandler);
              }
            } catch (err) {
              _didIteratorError21 = true;
              _iteratorError21 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion21 && _iterator21.return != null) {
                  _iterator21.return();
                }
              } finally {
                if (_didIteratorError21) {
                  throw _iteratorError21;
                }
              }
            }

            _el3.addEventListener('on.xt', onHandler); // @FIX off.xt toggle


            if (!options.off) {
              _el3.addEventListener('off.xt', onHandler);
            } // @FIX prevents click on touch until clicked two times


            if (events.includes('mouseenter') || events.includes('mousehover')) {
              var touchLinksStartHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(_el3, 'touchend.touchfix' + '.' + self.namespace, self.eventTouchLinksStartHandler.bind(self).bind(self, _el3));

              _el3.addEventListener('touchend', touchLinksStartHandler);
            }
          } // event off


          if (options.off) {
            var offHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(_el3, options.off + '.' + self.namespace, self.eventOffHandler.bind(self).bind(self, _el3));

            if (options.off) {
              var _events = _toConsumableArray(options.off.split(' '));

              var _iteratorNormalCompletion22 = true;
              var _didIteratorError22 = false;
              var _iteratorError22 = undefined;

              try {
                for (var _iterator22 = _events[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                  var _event3 = _step22.value;

                  _el3.addEventListener(_event3, offHandler);
                }
              } catch (err) {
                _didIteratorError22 = true;
                _iteratorError22 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion22 && _iterator22.return != null) {
                    _iterator22.return();
                  }
                } finally {
                  if (_didIteratorError22) {
                    throw _iteratorError22;
                  }
                }
              }
            }

            _el3.addEventListener('off.xt', offHandler);
          }
        } // listener

      } catch (err) {
        _didIteratorError13 = true;
        _iteratorError13 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
            _iterator13.return();
          }
        } finally {
          if (_didIteratorError13) {
            throw _iteratorError13;
          }
        }
      }

      var _iteratorNormalCompletion14 = true;
      var _didIteratorError14 = false;
      var _iteratorError14 = undefined;

      try {
        for (var _iterator14 = self.targets[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
          var tr = _step14.value;
          var _el4 = self.getElements(tr)[0];

          if (_el4) {
            // event
            var _onHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(_el4, options.on + '.' + self.namespace);

            tr.addEventListener('on.xt', _onHandler);

            var _offHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(_el4, options.off + '.' + self.namespace);

            tr.addEventListener('off.xt', _offHandler); // @FIX off.xt toggle

            if (!options.off) {
              tr.addEventListener('off.xt', _onHandler);
            }
          }
        } // auto

      } catch (err) {
        _didIteratorError14 = true;
        _iteratorError14 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
            _iterator14.return();
          }
        } finally {
          if (_didIteratorError14) {
            throw _iteratorError14;
          }
        }
      }

      if (options.auto && options.auto.time) {
        // focus auto
        var focusHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(window, 'focus' + '.' + self.namespace, self.eventAutoResumeHandler.bind(self));
        addEventListener('focus', focusHandler); // blur auto

        var blurHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(window, 'blur' + '.' + self.namespace, self.eventAutoPauseHandler.bind(self));
        addEventListener('blur', blurHandler); // autoPause

        if (options.auto && options.auto.pause) {
          var autoPauseEls = self.object.querySelectorAll(options.auto.pause);

          if (autoPauseEls.length) {
            var _self$destroyElements4;

            (_self$destroyElements4 = self.destroyElements).push.apply(_self$destroyElements4, _toConsumableArray(autoPauseEls));

            var _iteratorNormalCompletion15 = true;
            var _didIteratorError15 = false;
            var _iteratorError15 = undefined;

            try {
              for (var _iterator15 = autoPauseEls[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                var el = _step15.value;
                // pause
                var autoPauseOnHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(el, 'mouseenter focus' + '.' + self.namespace, self.eventAutoPauseHandler.bind(self));
                var eventsPause = ['mouseenter', 'focus'];

                for (var _i = 0, _eventsPause = eventsPause; _i < _eventsPause.length; _i++) {
                  var event = _eventsPause[_i];
                  el.addEventListener(event, autoPauseOnHandler);
                } // resume


                var autoResumeOnHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(el, 'mouseleave blur' + '.' + self.namespace, self.eventAutoResumeHandler.bind(self));
                var eventsResume = ['mouseleave', 'blur'];

                for (var _i2 = 0, _eventsResume = eventsResume; _i2 < _eventsResume.length; _i2++) {
                  var _event = _eventsResume[_i2];
                  el.addEventListener(_event, autoResumeOnHandler);
                }
              }
            } catch (err) {
              _didIteratorError15 = true;
              _iteratorError15 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion15 && _iterator15.return != null) {
                  _iterator15.return();
                }
              } finally {
                if (_didIteratorError15) {
                  throw _iteratorError15;
                }
              }
            }
          }
        }
      } // jump


      if (options.jump) {
        var _iteratorNormalCompletion16 = true;
        var _didIteratorError16 = false;
        var _iteratorError16 = undefined;

        try {
          for (var _iterator16 = self.targets[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
            var jump = _step16.value;
            var jumpHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(jump, 'click.jump' + '.' + self.namespace, self.eventJumpHandler.bind(self).bind(self, jump));
            jump.addEventListener('click', jumpHandler, true); // useCapture or it gets the click from elements inside the target
            // jump

            if (!self.disabled) {
              jump.classList.add('jump');
            } else {
              jump.classList.remove('jump');
            }
          }
        } catch (err) {
          _didIteratorError16 = true;
          _iteratorError16 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion16 && _iterator16.return != null) {
              _iterator16.return();
            }
          } finally {
            if (_didIteratorError16) {
              throw _iteratorError16;
            }
          }
        }
      } // navigation


      if (options.navigation) {
        self.navs = self.object.querySelectorAll(options.navigation);

        if (self.navs.length) {
          var _self$destroyElements5;

          (_self$destroyElements5 = self.destroyElements).push.apply(_self$destroyElements5, _toConsumableArray(self.navs));

          var _iteratorNormalCompletion17 = true;
          var _didIteratorError17 = false;
          var _iteratorError17 = undefined;

          try {
            for (var _iterator17 = self.navs[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
              var nav = _step17.value;
              var navHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(nav, 'click.nav' + '.' + self.namespace, self.eventNavHandler.bind(self).bind(self, nav));
              nav.addEventListener('click', navHandler);
            }
          } catch (err) {
            _didIteratorError17 = true;
            _iteratorError17 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion17 && _iterator17.return != null) {
                _iterator17.return();
              }
            } finally {
              if (_didIteratorError17) {
                throw _iteratorError17;
              }
            }
          }
        }
      } // keyboard


      if (options.keyboard && options.keyboard.selector) {
        var _self$destroyElements6;

        var keyboards = options.keyboard.selector === 'object' ? xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].arrSingle(self.object) : self.object.querySelectorAll(options.keyboard.selector);

        (_self$destroyElements6 = self.destroyElements).push.apply(_self$destroyElements6, _toConsumableArray(keyboards));

        var _iteratorNormalCompletion18 = true;
        var _didIteratorError18 = false;
        var _iteratorError18 = undefined;

        try {
          for (var _iterator18 = keyboards[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
            var keyboard = _step18.value;
            keyboard.setAttribute('tabindex', '0'); // focus

            var keyboardFocusHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(keyboard, 'focus.keyboard' + '.' + self.namespace, self.eventKeyboardFocusHandler.bind(self).bind(self, keyboard));
            keyboard.addEventListener('focus', keyboardFocusHandler); // blur

            var keyboardBlurHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(keyboard, 'blur.keyboard' + '.' + self.namespace, self.eventKeyboardBlurHandler.bind(self).bind(self, keyboard));
            keyboard.addEventListener('blur', keyboardBlurHandler);
          }
        } catch (err) {
          _didIteratorError18 = true;
          _iteratorError18 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion18 && _iterator18.return != null) {
              _iterator18.return();
            }
          } finally {
            if (_didIteratorError18) {
              throw _iteratorError18;
            }
          }
        }
      } // autoClose


      if (options.autoClose) {
        var autoCloseHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(window, 'autoClose' + '.' + self.namespace, self.eventAutoCloseHandler.bind(self));
        addEventListener('autoClose.xt', autoCloseHandler);
      } // images


      var _iteratorNormalCompletion19 = true;
      var _didIteratorError19 = false;
      var _iteratorError19 = undefined;

      try {
        for (var _iterator19 = self.elements.filter(function (x) {
          return !x.classList.contains('xt-clone');
        })[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
          var _self$destroyElements7;

          var _el5 = _step19.value;

          var imgs = _el5.querySelectorAll('img');

          (_self$destroyElements7 = self.destroyElements).push.apply(_self$destroyElements7, _toConsumableArray(imgs));

          var _iteratorNormalCompletion23 = true;
          var _didIteratorError23 = false;
          var _iteratorError23 = undefined;

          try {
            for (var _iterator23 = imgs[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
              var img = _step23.value;

              if (!xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(img, self.componentNamespace + 'ImageLoadedDone')) {
                xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(img, self.componentNamespace + 'ImageLoadedDone', true);

                if (!img.complete) {
                  var imgLoadHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(img, 'load' + '.' + self.namespace, self.eventImgLoadedHandler.bind(self).bind(self, _el5, true));
                  img.addEventListener('load', imgLoadHandler);
                } else {
                  self.eventImgLoadedHandler(_el5, false);
                }
              }
            }
          } catch (err) {
            _didIteratorError23 = true;
            _iteratorError23 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion23 && _iterator23.return != null) {
                _iterator23.return();
              }
            } finally {
              if (_didIteratorError23) {
                throw _iteratorError23;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError19 = true;
        _iteratorError19 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion19 && _iterator19.return != null) {
            _iterator19.return();
          }
        } finally {
          if (_didIteratorError19) {
            throw _iteratorError19;
          }
        }
      }

      var _iteratorNormalCompletion20 = true;
      var _didIteratorError20 = false;
      var _iteratorError20 = undefined;

      try {
        for (var _iterator20 = self.targets.filter(function (x) {
          return !x.classList.contains('xt-clone');
        })[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
          var _self$destroyElements8;

          var _tr2 = _step20.value;

          var _imgs = _tr2.querySelectorAll('img');

          (_self$destroyElements8 = self.destroyElements).push.apply(_self$destroyElements8, _toConsumableArray(_imgs));

          var _iteratorNormalCompletion24 = true;
          var _didIteratorError24 = false;
          var _iteratorError24 = undefined;

          try {
            for (var _iterator24 = _imgs[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
              var _img = _step24.value;

              if (!xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(_img, self.componentNamespace + 'ImageLoadedDone')) {
                xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(_img, self.componentNamespace + 'ImageLoadedDone', true);

                if (!_img.complete) {
                  var _imgLoadHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(_img, 'load' + '.' + self.namespace, self.eventImgLoadedHandler.bind(self).bind(self, _tr2, true));

                  _img.addEventListener('load', _imgLoadHandler);
                } else {
                  self.eventImgLoadedHandler(_tr2, false);
                }
              }
            }
          } catch (err) {
            _didIteratorError24 = true;
            _iteratorError24 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion24 && _iterator24.return != null) {
                _iterator24.return();
              }
            } finally {
              if (_didIteratorError24) {
                throw _iteratorError24;
              }
            }
          }
        } // wheel

      } catch (err) {
        _didIteratorError20 = true;
        _iteratorError20 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion20 && _iterator20.return != null) {
            _iterator20.return();
          }
        } finally {
          if (_didIteratorError20) {
            throw _iteratorError20;
          }
        }
      }

      if (options.wheel && options.wheel.selector) {
        var wheel = self.detail.wheel = options.wheel.selector === 'object' ? self.object : options.wheel.selector === 'scrollingElement' ? document.scrollingElement : self.object.querySelector(options.wheel.selector);
        self.destroyElements.push(wheel);
        var eWheel = 'onwheel' in wheel ? 'wheel' : wheel.onmousewheel !== undefined ? 'mousewheel' : 'DOMMouseScroll'; // wheel

        var wheelHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(wheel, eWheel + '.' + self.namespace, self.eventWheelHandler.bind(self));
        wheel.addEventListener(eWheel, wheelHandler, xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].passiveSupported ? {
          passive: false
        } : false); // stop

        var wheelStopHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(wheel, eWheel + '.stop' + '.' + self.namespace, self.eventWheelStop.bind(self));
        wheel.addEventListener('stop.wheel.xt', wheelStopHandler, xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].passiveSupported ? {
          passive: false
        } : false); // block

        if (options.wheel.block) {
          var block = wheel.parentNode;
          var wheelBlockHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(block, eWheel + '.block' + '.' + self.namespace, self.eventWheelBlockHandler.bind(self));
          block.addEventListener(eWheel, wheelBlockHandler, xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].passiveSupported ? {
            passive: false
          } : false);
        }
      }
    } //
    // handler
    //

    /**
     * element on handler
     * @param {Node|HTMLElement|EventTarget|Window} element
     * @param {Event} e
     */

  }, {
    key: "eventOnHandler",
    value: function eventOnHandler(element, e) {
      var self = this;
      var options = self.options; // handler

      if (element === e.target || // @FIX on.xt and off.xt event bubbles
      element.contains(e.target)) {
        // @FIX on.xt and off.xt event bubbles (use only in library)
        if (!e || !e.detail || !e.detail.skip) {
          // @FIX filter triggered from library (use only in library)
          // event block
          if (options.onBlock) {
            var now = new Date().getTime();
            var old = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(element, self.componentNamespace + 'EventBlock' + e.type) || 0;
            xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(element, self.componentNamespace + 'EventBlock' + e.type, now);

            if (now - old < options.onBlock) {
              return;
            }
          } // on handler


          var eventLimit = self.container.querySelectorAll('.event-limit');

          if (eventLimit.length) {
            if (!xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].checkNested(e.target, eventLimit)) {
              self.eventOn(element, false, e);
            }
          } else {
            self.eventOn(element, false, e);
          }
        }
      }
    }
    /**
     * element off handler
     * @param {Node|HTMLElement|EventTarget|Window} element
     * @param {Event} e
     */

  }, {
    key: "eventOffHandler",
    value: function eventOffHandler(element, e) {
      var self = this;
      var options = self.options; // handler

      if (element === e.target || // @FIX on.xt and off.xt event bubbles
      element.contains(e.target)) {
        // @FIX on.xt and off.xt event bubbles (use only in library)
        if (!e || !e.detail || !e.detail.skip) {
          // @FIX filter triggered from library (use only in library)
          // event block
          if (options.offBlock) {
            var now = new Date().getTime();
            var old = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(element, self.componentNamespace + 'EventBlock' + e.type) || 0;
            xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(element, self.componentNamespace + 'EventBlock' + e.type, now);

            if (now - old < options.offBlock) {
              return;
            }
          } // off handler


          var eventLimit = self.container.querySelectorAll('.event-limit');

          if (eventLimit.length) {
            if (!xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].checkNested(e.target, eventLimit)) {
              self.eventOff(element, false, e);
            }
          } else {
            self.eventOff(element, false, e);
          }
        }
      }
    }
    /**
     * init prevents click on touch until clicked two times
     * @param {Node|HTMLElement|EventTarget|Window} el
     * @param {Event} e
     */

  }, {
    key: "eventTouchLinksStartHandler",
    value: function eventTouchLinksStartHandler(el, e) {
      var self = this; // event touchLinks

      var touchLinksHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(el, 'click.touchfix' + '.' + self.namespace, self.eventTouchLinksHandler.bind(self).bind(self, el));
      el.addEventListener('click', touchLinksHandler); // event touchReset

      var touchResetHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(el, 'off.touchfix' + '.' + self.namespace, self.eventTouchLinksResetHandler.bind(self).bind(self, el));
      el.addEventListener('off.xt', touchResetHandler);
    }
    /**
     * remove prevents click on touch until clicked two times
     * @param {Node|HTMLElement|EventTarget|Window} el
     */

  }, {
    key: "eventTouchLinksEndHandler",
    value: function eventTouchLinksEndHandler(el) {
      var self = this; // event touchLinks

      var touchLinksHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, 'click.touchfix' + '.' + self.namespace);
      el.removeEventListener('click', touchLinksHandler); // event touchReset

      var touchResetHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, 'off.touchfix' + '.' + self.namespace);
      el.removeEventListener('off.xt', touchResetHandler);
    }
    /**
     * prevents click on touch until clicked two times
     * @param {Node|HTMLElement|EventTarget|Window} el
     * @param {Event} e
     */

  }, {
    key: "eventTouchLinksHandler",
    value: function eventTouchLinksHandler(el, e) {
      var self = this;

      if (!xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'TouchLinksDone')) {
        xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'TouchLinksDone', true); // prevent default

        e.preventDefault();
      } else {
        self.eventTouchLinksEndHandler(el);
        xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.remove(el, self.componentNamespace + 'TouchLinksDone');
      }
    }
    /**
     * reset prevents click on touch until clicked two times
     * @param {Node|HTMLElement|EventTarget|Window} el
     * @param {Event} e
     */

  }, {
    key: "eventTouchLinksResetHandler",
    value: function eventTouchLinksResetHandler(el, e) {
      var self = this;
      self.eventTouchLinksEndHandler(el);
      xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.remove(el, self.componentNamespace + 'TouchLinksDone');
    }
    /**
     * auto pause handler
     * @param {Event} e
     */

  }, {
    key: "eventAutoPauseHandler",
    value: function eventAutoPauseHandler(e) {
      var self = this;

      if (!e || !e.detail || !e.detail.skip) {
        // @FIX filter triggered from library (use only in library)
        if (!self.detail.autoPaused) {
          self.eventAutoPause(); // paused

          self.detail.autoPaused = true;
        }
      }
    }
    /**
     * auto resume handler
     * @param {Event} e
     */

  }, {
    key: "eventAutoResumeHandler",
    value: function eventAutoResumeHandler(e) {
      var self = this;

      if (!e || !e.detail || !e.detail.skip) {
        // @FIX filter triggered from library (use only in library)
        if (self.detail.autoPaused) {
          self.eventAutoStart(); // paused

          self.detail.autoPaused = false;
        }
      }
    }
    /**
     * jump handler
     * @param {Node|HTMLElement|EventTarget|Window} el
     * @param {Event} e
     */

  }, {
    key: "eventJumpHandler",
    value: function eventJumpHandler(el, e) {
      var self = this; // handler

      self.eventJump(el, e);
    }
    /**
     * nav handler
     * @param {Node|HTMLElement|EventTarget|Window} nav
     * @param {Event} e
     */

  }, {
    key: "eventNavHandler",
    value: function eventNavHandler(nav, e) {
      var self = this; // handler

      self.eventNav(nav, e);
    }
    /**
     * keyboard focus handler
     * @param {Node|HTMLElement|EventTarget|Window} el
     * @param {Event} e
     */

  }, {
    key: "eventKeyboardFocusHandler",
    value: function eventKeyboardFocusHandler(el, e) {
      var self = this; // handler

      var keyboardHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(document, 'keyup.keyboard' + '.' + self.namespace, self.eventKeyboardHandler.bind(self));
      document.addEventListener('keyup', keyboardHandler);
    }
    /**
     * keyboard blur handler
     * @param {Node|HTMLElement|EventTarget|Window} el
     * @param {Event} e
     */

  }, {
    key: "eventKeyboardBlurHandler",
    value: function eventKeyboardBlurHandler(el, e) {
      // handler
      var keyboardHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(document, 'keyup.keyboard' + '.' + self.namespace);
      document.removeEventListener('keyup', keyboardHandler);
    }
    /**
     * keyboard handler
     * @param {Event} e
     */

  }, {
    key: "eventKeyboardHandler",
    value: function eventKeyboardHandler(e) {
      var self = this;
      var options = self.options; // key

      var code = e.keyCode ? e.keyCode : e.which;
      var prev;
      var next;

      if (options.keyboard.vertical) {
        if (options.keyboard.inverse) {
          prev = 40;
          next = 38;
        } else {
          prev = 38;
          next = 40;
        }
      } else {
        if (options.keyboard.inverse) {
          prev = 39;
          next = 37;
        } else {
          prev = 37;
          next = 39;
        }
      }

      if (code === prev) {
        self.goToPrev(1);
      } else if (code === next) {
        self.goToNext(1);
      }
    }
    /**
     * autoClose handler
     * @param {Event} e
     */

  }, {
    key: "eventAutoCloseHandler",
    value: function eventAutoCloseHandler(e) {
      var self = this; // restart

      var currents = self.getCurrents();
      var _iteratorNormalCompletion25 = true;
      var _didIteratorError25 = false;
      var _iteratorError25 = undefined;

      try {
        for (var _iterator25 = currents[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
          var current = _step25.value;
          self.eventOff(current, true);
        }
      } catch (err) {
        _didIteratorError25 = true;
        _iteratorError25 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion25 && _iterator25.return != null) {
            _iterator25.return();
          }
        } finally {
          if (_didIteratorError25) {
            throw _iteratorError25;
          }
        }
      }
    }
    /**
     * imageLoaded
     * @param {Node|HTMLElement|EventTarget|Window} el
     * @param {Boolean} deferred
     */

  }, {
    key: "eventImgLoadedHandler",
    value: function eventImgLoadedHandler(el) {
      var deferred = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var self = this;
      var options = self.options; // class

      el.classList.add('xt-imageLoaded'); // listener dispatch

      var detail = self.eDetailSet();
      detail.deferred = deferred;
      el.dispatchEvent(new CustomEvent('imageLoaded.xt', {
        bubbles: true,
        detail: detail
      })); // imageLoadedInit

      if (options.imageLoadedInit && deferred) {
        clearTimeout(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(self.object, 'xt' + self.componentNamespace + 'imageLoadedInit' + 'Timeout'));
        xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(self.object, 'xt' + self.componentNamespace + 'imageLoadedInit' + 'Timeout', setTimeout(function () {
          self.initLogic();
        }, xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].imageLoadedDelay));
      }
    } //
    // event util
    //

    /**
     * get groups (one element per group)
     * @returns {Array} array of elements
     */

  }, {
    key: "getGroups",
    value: function getGroups() {
      var self = this; // groups

      var groups = [];
      var _iteratorNormalCompletion26 = true;
      var _didIteratorError26 = false;
      var _iteratorError26 = undefined;

      try {
        var _loop2 = function _loop2() {
          var element = _step26.value;
          // choose element by group
          var group = element.getAttribute('data-xt-group');

          if (group) {
            var found = groups.filter(function (x) {
              return x.getAttribute('data-xt-group') === group;
            });

            if (!found.length) {
              groups.push(element);
            }
          } else {
            groups.push(element);
          }
        };

        for (var _iterator26 = self.elements[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
          _loop2();
        }
      } catch (err) {
        _didIteratorError26 = true;
        _iteratorError26 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion26 && _iterator26.return != null) {
            _iterator26.return();
          }
        } finally {
          if (_didIteratorError26) {
            throw _iteratorError26;
          }
        }
      }

      return groups;
    }
    /**
     * get elements from element or target
     * @param {Node|HTMLElement|EventTarget|Window} el Element that triggered interaction
     * @returns {Array} The first element is the one on getGroups()
     */

  }, {
    key: "getElements",
    value: function getElements(el) {
      var self = this; // getElements

      if (!self.elements || !self.elements.length) {
        return [];
      }

      if (self.mode === 'unique' || !el) {
        // choose all elements
        return self.elements;
      } else if (self.mode === 'multiple') {
        // choose element by group
        var final;
        var group = el.getAttribute('data-xt-group');
        var groupElements = Array.from(self.elements).filter(function (x) {
          return x.getAttribute('data-xt-group') === group;
        });
        var groupTargets = Array.from(self.targets).filter(function (x) {
          return x.getAttribute('data-xt-group') === group;
        });

        if (group) {
          // all group targets if group
          final = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].arrSingle(groupElements);
        } else {
          // not group targets by index if not group
          if (Array.from(self.elements).includes(el)) {
            // @FIX when argument is already element
            final = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].arrSingle(el);
          } else {
            var index = groupTargets.findIndex(function (x) {
              return x === el;
            });
            final = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].arrSingle(groupElements[index]);
          }
        }

        return final;
      }
    }
    /**
     * get targets from element or target
     * @param {Node|HTMLElement|EventTarget|Window} el Element that triggered interaction
     * @returns {Array}
     */

  }, {
    key: "getTargets",
    value: function getTargets(el) {
      var self = this; // getTargets

      if (!self.targets || !self.targets.length) {
        return [];
      }

      if (self.mode === 'unique' || !el) {
        // choose all targets
        return self.targets;
      } else if (self.mode === 'multiple') {
        // choose only target by group
        var final;
        var group = el.getAttribute('data-xt-group');
        var groupElements = Array.from(self.elements).filter(function (x) {
          return x.getAttribute('data-xt-group') === group;
        });
        var groupTargets = Array.from(self.targets).filter(function (x) {
          return x.getAttribute('data-xt-group') === group;
        });

        if (group) {
          // all group targets if group
          final = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].arrSingle(groupTargets);
        } else {
          // not group targets by index if not group
          if (Array.from(self.targets).includes(el)) {
            // @FIX when argument is already target
            final = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].arrSingle(el);
          } else {
            var index = groupElements.findIndex(function (x) {
              return x === el;
            });
            final = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].arrSingle(groupTargets[index]);
          }
        }

        return final;
      }
    }
    /**
     * get currents based on namespace (so shared between Xt objects)
     * @returns {Array}
     */

  }, {
    key: "getCurrents",
    value: function getCurrents() {
      var self = this; // getCurrents

      return xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].currents[self.namespace];
    }
    /**
     * set currents based on namespace (so shared between Xt objects)
     * @param {Array} arr
     */

  }, {
    key: "setCurrents",
    value: function setCurrents(arr) {
      var self = this; // setCurrents

      xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].currents[self.namespace] = arr;
    }
    /**
     * add current based on namespace (so shared between Xt objects)
     * @param {Node|HTMLElement|EventTarget|Window} element To be added
     */

  }, {
    key: "addCurrent",
    value: function addCurrent(element) {
      var self = this; // addCurrent

      if (!self.hasCurrent(element)) {
        var arr = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].currents[self.namespace];
        arr.push(element);
      }
    }
    /**
     * remove currents based on namespace (so shared between Xt objects)
     * @param {Node|HTMLElement|EventTarget|Window} element To be removed
     */

  }, {
    key: "removeCurrent",
    value: function removeCurrent(element) {
      var self = this; // removeCurrent

      xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].currents[self.namespace] = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].currents[self.namespace].filter(function (x) {
        return x !== element;
      });
    }
    /**
     * if element or target is in current (so shared between Xt objects)
     * @param {Node|HTMLElement|EventTarget|Window} element To be checked
     */

  }, {
    key: "hasCurrent",
    value: function hasCurrent(element) {
      var self = this; // hasCurrent

      var groupElements = self.getElements(element);
      return xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].currents[self.namespace].filter(function (x) {
        return x === groupElements[0];
      }).length;
    }
    /**
     * check element on
     * @param {Node|HTMLElement|EventTarget|Window} element To be checked
     * @returns {Boolean} If elements can activate
     */

  }, {
    key: "checkOn",
    value: function checkOn(element) {
      var self = this; // check

      return !self.hasCurrent(element);
    }
    /**
     * check element off
     * @param {Node|HTMLElement|EventTarget|Window} element To be checked
     * @returns {Boolean} If elements can deactivate
     */

  }, {
    key: "checkOff",
    value: function checkOff(element) {
      var self = this;
      var options = self.options; // skip if min >= currents

      if (options.min - self.getCurrents().length >= 0) {
        return false;
      } // check


      return self.hasCurrent(element);
    }
    /**
     * check elements animation
     * @param {NodeList|Array} elements To be checked
     * @returns {Boolean} If elements are animating
     */

  }, {
    key: "checkAnim",
    value: function checkAnim(elements) {
      var self = this; // check

      elements = elements.filter(function (x) {
        return x.matches(self.classesInMatch) || x.matches(self.classesOutMatch);
      });
      return elements.length > 0;
    }
    /**
     * set index and direction
     * @param {Node|HTMLElement|EventTarget|Window} element Current element
     */

  }, {
    key: "setIndexAndDirection",
    value: function setIndexAndDirection(element) {
      var self = this; // setIndexAndDirection

      var index = 0;
      var _iteratorNormalCompletion27 = true;
      var _didIteratorError27 = false;
      var _iteratorError27 = undefined;

      try {
        for (var _iterator27 = self.elements.entries()[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
          var _step27$value = _slicedToArray(_step27.value, 2),
              i = _step27$value[0],
              el = _step27$value[1];

          if (el === element) {
            index = i;
            break;
          }
        }
      } catch (err) {
        _didIteratorError27 = true;
        _iteratorError27 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion27 && _iterator27.return != null) {
            _iterator27.return();
          }
        } finally {
          if (_didIteratorError27) {
            throw _iteratorError27;
          }
        }
      }

      self.detail.inverse = self.detail.inverseForce !== null ? self.detail.inverseForce : self.currentIndex > index;
      self.detail.inverseForce = null;
      self.currentIndex = index;
    }
    /**
     * set e detail
     * @param {Event} e
     */

  }, {
    key: "eDetailSet",
    value: function eDetailSet() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      // e.detail
      var detail = e && e.detail && _typeof(e.detail) === 'object' ? e.detail : {}; // detail

      detail.self = this;
      detail.skip = true; // return

      return detail;
    }
    /**
     * activate element
     * @param {Node|HTMLElement|EventTarget|Window} el Elements to be activated
     */

  }, {
    key: "activate",
    value: function activate(el) {
      var _el$classList, _el$classList2, _el$classList3;

      var self = this; // activate

      (_el$classList = el.classList).add.apply(_el$classList, _toConsumableArray(self.classes));

      (_el$classList2 = el.classList).add.apply(_el$classList2, _toConsumableArray(self.classesIn));

      (_el$classList3 = el.classList).remove.apply(_el$classList3, _toConsumableArray(self.classesOut));

      if (self.initial || xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'Initial')) {
        var _el$classList4;

        (_el$classList4 = el.classList).add.apply(_el$classList4, _toConsumableArray(self.classesInitial));
      }

      if (!self.detail.inverse) {
        var _el$classList5;

        (_el$classList5 = el.classList).remove.apply(_el$classList5, _toConsumableArray(self.classesInverse));
      } else {
        var _el$classList6;

        (_el$classList6 = el.classList).add.apply(_el$classList6, _toConsumableArray(self.classesInverse));
      }
    }
    /**
     * deactivate element
     * @param {Node|HTMLElement|EventTarget|Window} el Elements to be deactivated
     */

  }, {
    key: "deactivate",
    value: function deactivate(el) {
      var _el$classList7, _el$classList8, _el$classList9;

      var self = this; // activate

      (_el$classList7 = el.classList).remove.apply(_el$classList7, _toConsumableArray(self.classes));

      (_el$classList8 = el.classList).remove.apply(_el$classList8, _toConsumableArray(self.classesIn));

      (_el$classList9 = el.classList).add.apply(_el$classList9, _toConsumableArray(self.classesOut));

      if (!self.initial && !xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'Initial')) {
        var _el$classList10;

        (_el$classList10 = el.classList).remove.apply(_el$classList10, _toConsumableArray(self.classesInitial));
      }

      if (!self.detail.inverse) {
        var _el$classList11;

        (_el$classList11 = el.classList).remove.apply(_el$classList11, _toConsumableArray(self.classesInverse));
      } else {
        var _el$classList12;

        (_el$classList12 = el.classList).add.apply(_el$classList12, _toConsumableArray(self.classesInverse));
      }
    } //
    // event
    //

    /**
     * element on
     * @param {Node|HTMLElement|EventTarget|Window} element To be activated
     * @param {Boolean} force
     * @param {Event} e
     * @returns {Boolean} If activated
     */

  }, {
    key: "eventOn",
    value: function eventOn(element) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var e = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var self = this;
      var options = self.options; // disabled

      if (self.disabled && !self.initial) {
        return false;
      } // toggle


      if (force || self.checkOn(element) && (!e || !e.type || e.type !== 'off.xt')) {
        // @FIX off.xt toggle
        // auto
        if (options.auto && options.auto.time) {
          self.eventAutoStop();
        } // on


        var groupElements = self.getElements(element);
        self.addCurrent(groupElements[0]);
        self.setIndexAndDirection(element);
        var targets = self.getTargets(element);
        var elementsInner = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].queryAll(element, options.elementsInner);
        var targetsInner = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].queryAll(targets, options.targetsInner); // if currents > max

        var currents = self.getCurrents();

        if (currents.length > options.max) {
          // deactivate old
          self.eventOff(currents[0]);
        } // detail


        var detail = self.eDetailSet(e); // queue obj

        var actionCurrent = 'On';
        var actionOther = 'Off';
        self.eventQueue(actionCurrent, detail, groupElements, targets, elementsInner, targetsInner); // queue run

        for (var type in self.detail['queue' + actionCurrent][0]) {
          self.queueStart(actionCurrent, actionOther, type, 0, true);
        } // activated


        return true;
      } else if (!e || !e.type || e.type !== 'on.xt') {
        // @FIX off.xt toggle
        // off
        self.eventOff(element, false, e);
      } // activated


      return false;
    }
    /**
     * element off
     * @param {Node|HTMLElement|EventTarget|Window} element To be deactivated
     * @param {Boolean} force
     * @param {Event} e
     * @returns {Boolean} If deactivated
     */

  }, {
    key: "eventOff",
    value: function eventOff(element) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var e = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var self = this;
      var options = self.options; // disabled

      if (self.disabled && !self.initial) {
        return false;
      } // toggle


      if (force || self.checkOff(element)) {
        // off
        var groupElements = self.getElements(element);
        self.removeCurrent(groupElements[0]);
        var targets = self.getTargets(element);
        var elementsInner = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].queryAll(element, options.elementsInner);
        var targetsInner = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].queryAll(targets, options.targetsInner);

        if (element.blur) {
          // @FIX sometimes blur is undefined
          element.blur(); // @FIX :focus styles
        } // currentIndex after a frame for sequential events


        requestAnimationFrame(function () {
          if (self.getCurrents().length === 0) {
            self.currentIndex = null;
          }
        }); // auto

        if (!self.getCurrents().length) {
          self.eventAutoStop();
        } // detail


        var detail = self.eDetailSet(e); // queue obj

        var actionCurrent = 'Off';
        var actionOther = 'On';
        self.eventQueue(actionCurrent, detail, groupElements, targets, elementsInner, targetsInner); // if queue too big

        if (self.detail['queue' + actionCurrent].length > options.max) {
          // remove queue on and done other queue
          var removedOn = self.detail['queue' + actionOther].shift();
          self.queueStop(actionOther, actionCurrent, removedOn); // remove queue off and done other queue

          var removedOff = self.detail['queue' + actionCurrent].shift();
          self.queueStop(actionCurrent, actionOther, removedOff);
        } // queue run


        for (var type in self.detail['queue' + actionCurrent][0]) {
          self.queueStart(actionCurrent, actionOther, type, 0, true);
        } // deactivated


        return true;
      } // deactivated


      return false;
    }
    /**
     * element on
     * @param {String} actionCurrent
     * @param {Event} detail
     * @param {NodeList|Array|Node|HTMLElement|EventTarget|Window} groupElements
     * @param {NodeList|Array|Node|HTMLElement|EventTarget|Window} targets
     * @param {NodeList|Array|Node|HTMLElement|EventTarget|Window} elementsInner
     * @param {NodeList|Array|Node|HTMLElement|EventTarget|Window} targetsInner
     */

  }, {
    key: "eventQueue",
    value: function eventQueue(actionCurrent, detail, groupElements, targets, elementsInner, targetsInner) {
      var self = this;
      var options = self.options; // populate

      var obj = {};
      obj.elements = {
        detail: detail,
        queueEls: groupElements
      };

      if (targets.length) {
        obj.targets = {
          detail: detail,
          queueEls: targets
        };
      }

      if (elementsInner.length) {
        obj.elementsInner = {
          detail: detail,
          queueEls: elementsInner
        };
      }

      if (targetsInner.length) {
        obj.targetsInner = {
          detail: detail,
          queueEls: targetsInner
        };
      } // put in queue


      if (_typeof(options.instant) !== 'object' && options.instant === true) {
        self.detail['queue' + actionCurrent] = [obj];
      } else {
        self.detail['queue' + actionCurrent].unshift(obj);
      }
    }
    /**
     * auto start
     */

  }, {
    key: "eventAutoStart",
    value: function eventAutoStart() {
      var self = this;
      var options = self.options; // disabled

      if (self.disabled && !self.initial) {
        return;
      } // start


      if (options.auto && options.auto.time) {
        // paused
        self.detail.autoPaused = false; // clear

        clearInterval(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(self.object, self.componentNamespace + 'AutoStartInterval')); // auto

        var time = options.auto.time;

        if (self.currentIndex !== null && ( // not when nothing activated
        !self.initial || options.auto.initial)) {
          // not when initial
          xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(self.object, self.componentNamespace + 'AutoStartInterval', setInterval(function () {
            // interval because can become :visible
            if (xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].visible(self.object)) {
              // auto
              if (getComputedStyle(self.object).pointerEvents !== 'none') {
                // not when disabled
                if (options.auto.inverse) {
                  self.goToPrev(options.auto.step, true);
                } else {
                  self.goToNext(options.auto.step, true);
                }
              }
            }
          }, time)); // listener dispatch

          var detail = self.eDetailSet();
          self.object.dispatchEvent(new CustomEvent('start.xt.auto', {
            detail: detail
          }));
        }
      }
    }
    /**
     * auto stop
     */

  }, {
    key: "eventAutoStop",
    value: function eventAutoStop() {
      var self = this;
      var options = self.options; // disabled

      if (self.disabled && !self.initial) {
        return;
      } // stop


      if (options.auto && options.auto.time) {
        // clear
        clearInterval(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(self.object, self.componentNamespace + 'AutoStartInterval')); // listener dispatch

        var detail = self.eDetailSet();
        self.object.dispatchEvent(new CustomEvent('stop.xt.auto', {
          detail: detail
        }));
      }
    }
    /**
     * auto stop
     */

  }, {
    key: "eventAutoPause",
    value: function eventAutoPause() {
      var self = this;
      var options = self.options; // disabled

      if (self.disabled && !self.initial) {
        return;
      } // pause


      if (options.auto && options.auto.time) {
        // clear
        clearInterval(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(self.object, self.componentNamespace + 'AutoStartInterval')); // listener dispatch

        var detail = self.eDetailSet();
        self.object.dispatchEvent(new CustomEvent('pause.xt.auto', {
          detail: detail
        }));
      }
    }
    /**
     * jump
     * @param {Node|HTMLElement|EventTarget|Window} el
     * @param {Event} e
     */

  }, {
    key: "eventJump",
    value: function eventJump(el, e) {
      var self = this; // disabled

      if (self.disabled && !self.initial) {
        return;
      } // check disabled


      if (el.closest('.jumps--none')) {
        return;
      } // jump


      var element = self.getTargets(el)[0];

      if (self.checkOn(element)) {
        self.eventOn(element);
      }
    }
    /**
     * nav
     * @param {Node|HTMLElement|EventTarget|Window} nav
     * @param {Event} e
     */

  }, {
    key: "eventNav",
    value: function eventNav(nav, e) {
      var self = this; // disabled

      if (self.disabled && !self.initial) {
        return;
      } // nav


      var index = 0;

      if (self.currentIndex !== null) {
        index = self.currentIndex + parseFloat(nav.getAttribute('data-xt-nav'));
      }

      self.goToIndex(index, true);
    } //
    // queue
    //

    /**
     * queue start
     * @param {String} actionCurrent Current action
     * @param {String} actionOther Other action
     * @param {String} type Type of element
     * @param {Number} index Queue index
     * @param {Boolean} queueInitial If it's the initial queue
     */

  }, {
    key: "queueStart",
    value: function queueStart(actionCurrent, actionOther, type, index) {
      var queueInitial = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var self = this;
      var options = self.options; // queue start

      var obj = self.detail['queue' + actionCurrent][index];

      if (obj && obj[type] && !obj[type].done) {
        var objOther = self.detail['queue' + actionOther][self.detail['queue' + actionOther].length - 1];

        if (!objOther || !objOther[type] || objOther[type].done) {
          if (_typeof(options.instant) !== 'object' && options.instant === true) {
            obj[type].instant = true;
          } else if (_typeof(options.instant) === 'object' && options.instant[type]) {
            obj[type].instantType = true;
          }

          self.queueDelay(actionCurrent, actionOther, obj, type, queueInitial);
        }
      }
    }
    /**
     * queue stop
     * @param {String} actionCurrent Current action
     * @param {String} actionOther Other action
     * @param {Object} obj Queue object to end
     */

  }, {
    key: "queueStop",
    value: function queueStop(actionCurrent, actionOther, obj) {
      var self = this; // stop type if done

      for (var type in obj) {
        if (obj[type].done) {
          var _iteratorNormalCompletion28 = true;
          var _didIteratorError28 = false;
          var _iteratorError28 = undefined;

          try {
            for (var _iterator28 = obj[type].queueEls[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
              var el = _step28.value;
              // clear timeout and frame
              cancelAnimationFrame(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'CollapseFrame'));
              clearTimeout(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'DelayTimeout'));
              clearTimeout(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'AnimTimeout')); // done other queue

              self.queueDelayDone(actionOther, actionCurrent, obj, el, type, true);
              self.queueAnimDone(actionOther, actionCurrent, obj, el, type, true);
            }
          } catch (err) {
            _didIteratorError28 = true;
            _iteratorError28 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion28 && _iterator28.return != null) {
                _iterator28.return();
              }
            } finally {
              if (_didIteratorError28) {
                throw _iteratorError28;
              }
            }
          }
        }
      }
    }
    /**
     * queue stop all
     */

  }, {
    key: "queueStopAll",
    value: function queueStopAll() {
      var self = this; // stop all obj in queues

      var actions = [{
        current: 'On',
        other: 'Off'
      }, {
        current: 'Off',
        other: 'On'
      }];

      for (var _i3 = 0, _actions = actions; _i3 < _actions.length; _i3++) {
        var action = _actions[_i3];
        var queue = self.detail['queue' + action.current];

        for (var obj in queue) {
          self.queueStop(action.current, action.other, obj);
        }
      }
    }
    /**
     * queue delay
     * @param {String} actionCurrent Current action
     * @param {String} actionOther Other action
     * @param {Object} obj Queue object
     * @param {String} type Type of elements
     * @param {Boolean} queueInitial If it's the initial queue
     */

  }, {
    key: "queueDelay",
    value: function queueDelay(actionCurrent, actionOther, obj, type, queueInitial) {
      var self = this;
      var options = self.options; // delay

      var els = obj[type].queueEls;
      var _iteratorNormalCompletion29 = true;
      var _didIteratorError29 = false;
      var _iteratorError29 = undefined;

      try {
        var _loop3 = function _loop3() {
          var el = _step29.value;
          // delay
          var delay = options['delay' + actionCurrent];

          if (delay) {
            if (isNaN(delay)) {
              var count = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + actionCurrent + 'Count') || els.findIndex(function (x) {
                return x === el;
              });
              var tot = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + actionCurrent + 'Tot') || els.length;

              if (typeof delay === 'function') {
                delay = delay(count, tot - 1);
              }
            } else {
              delay = queueInitial ? 0 : delay;
            }
          } // delay fnc


          clearTimeout(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'DelayTimeout'));
          clearTimeout(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'AnimTimeout'));

          if (delay) {
            xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'DelayTimeout', setTimeout(function () {
              self.queueDelayDone(actionCurrent, actionOther, obj, el, type);
            }, delay));
          } else {
            self.queueDelayDone(actionCurrent, actionOther, obj, el, type);
          } // queue done


          if (obj[type].instant) {
            if (el === els[els.length - 1]) {
              // only if last element
              self.queueDone(actionCurrent, actionOther, obj, type);
            }
          }
        };

        for (var _iterator29 = els[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
          _loop3();
        }
      } catch (err) {
        _didIteratorError29 = true;
        _iteratorError29 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion29 && _iterator29.return != null) {
            _iterator29.return();
          }
        } finally {
          if (_didIteratorError29) {
            throw _iteratorError29;
          }
        }
      }
    }
    /**
     * queue delay done
     * @param {String} actionCurrent Current action
     * @param {String} actionOther Other action
     * @param {Object} obj Queue object
     * @param {Node|HTMLElement|EventTarget|Window} el Elements to be deactivated
     * @param {String} type Type of elements
     * @param {Boolean} skipQueue If skip queue
     */

  }, {
    key: "queueDelayDone",
    value: function queueDelayDone(actionCurrent, actionOther, obj, el, type) {
      var skipQueue = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      var self = this;
      var options = self.options;

      if (actionCurrent === 'On') {
        // activate
        self.activate(el); // special

        var before = getComputedStyle(el, ':before').getPropertyValue('content').replace(/['"]+/g, '');
        var after = getComputedStyle(el, ':after').getPropertyValue('content').replace(/['"]+/g, '');
        self.specialCenter(el, before, after);
        self.specialMiddle(el, before, after);
        self.specialCollapse(actionCurrent, el, before, after);

        if (type === 'targets' || !self.targets.length && type === 'elements') {
          // @FIX when standalone
          // appendTo
          if (options.appendTo) {
            var appendToTarget = document.querySelector(options.appendTo);
            var appendOrigin = document.querySelector('[data-xt-origin=' + self.namespace + ']');

            if (!appendOrigin) {
              el.before(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].createElement('<div class="xt-ignore" data-xt-origin=' + self.namespace + '></div>'));
            }

            el.classList.add('xt-ignore', 'xt-ignore--once'); // @FIX ignore once for mount when moving

            appendToTarget.appendChild(el);
          }
        }

        if (type === 'targets' || type === 'targetsInner') {
          self.specialClose(actionCurrent, el, obj.elements.queueEls[0]);
        } // aria


        if (options.aria) {
          if (type === 'elements') {
            // selected
            var ariaEls = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].queryAll(el, options.ariaControls);
            var ariaEl = ariaEls.length ? ariaEls[0] : el;
            ariaEl.setAttribute('aria-selected', 'true');
          }

          if (type === 'targets') {
            // expanded
            var role = el.getAttribute('role');

            if (role === 'tabpanel' || role === 'listbox' || role === 'dialog') {
              el.setAttribute('aria-expanded', 'true');
            }
          }
        } // listener dispatch


        el.dispatchEvent(new CustomEvent('on.xt', {
          bubbles: true,
          detail: obj[type].detail
        }));
      } else if (actionCurrent === 'Off') {
        // deactivate
        self.deactivate(el); // special

        var _before = getComputedStyle(el, ':before').getPropertyValue('content').replace(/['"]+/g, '');

        var _after = getComputedStyle(el, ':after').getPropertyValue('content').replace(/['"]+/g, '');

        self.specialCollapse(actionCurrent, el, _before, _after);

        if (type === 'targets' || type === 'targetsInner') {
          self.specialClose(actionCurrent, el);
        } // listener dispatch


        el.dispatchEvent(new CustomEvent('off.xt', {
          bubbles: true,
          detail: obj[type].detail
        }));
      } // queue


      if (!skipQueue) {
        self.queueAnim(actionCurrent, actionOther, obj, el, type); // queue done

        if (obj[type].instantType) {
          var els = obj[type].queueEls;

          if (el === els[els.length - 1]) {
            // only if last element
            self.queueDone(actionCurrent, actionOther, obj, type);
          }
        }
      }
    }
    /**
     * queue anim
     * @param {String} actionCurrent Current action
     * @param {String} actionOther Other action
     * @param {Object} obj Queue object
     * @param {Node|HTMLElement|EventTarget|Window} el Element to be animated
     * @param {String} type Type of element
     */

  }, {
    key: "queueAnim",
    value: function queueAnim(actionCurrent, actionOther, obj, el, type) {
      var self = this;
      var options = self.options; // anim

      var duration = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].animTime(el, options['duration' + actionCurrent]);
      clearTimeout(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'AnimTimeout'));

      if (!duration) {
        self.queueAnimDone(actionCurrent, actionOther, obj, el, type);
      } else {
        xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'AnimTimeout', setTimeout(function () {
          self.queueAnimDone(actionCurrent, actionOther, obj, el, type);
        }, duration));
      }
    }
    /**
     * queue anim done
     * @param {String} actionCurrent Current action
     * @param {String} actionOther Other action
     * @param {Object} obj Queue object
     * @param {Node|HTMLElement|EventTarget|Window} el Element to be animated
     * @param {String} type Type of element
     * @param {Boolean} skipQueue If skip queue
     */

  }, {
    key: "queueAnimDone",
    value: function queueAnimDone(actionCurrent, actionOther, obj, el, type) {
      var skipQueue = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      var self = this;
      var options = self.options;

      if (actionCurrent === 'On') {
        var _el$classList13;

        // reset
        (_el$classList13 = el.classList).remove.apply(_el$classList13, _toConsumableArray(self.classesIn)); // special


        var before = getComputedStyle(el, ':before').getPropertyValue('content').replace(/['"]+/g, '');
        var after = getComputedStyle(el, ':after').getPropertyValue('content').replace(/['"]+/g, '');
        self.specialCollapse('Reset', el, before, after); // aria

        if (options.aria) {
          // tabindex
          if (options.aria === true || options.aria.tabindex) {
            if (type === 'targets') {
              var focusables = el.querySelectorAll(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].focusables);
              var _iteratorNormalCompletion30 = true;
              var _didIteratorError30 = false;
              var _iteratorError30 = undefined;

              try {
                for (var _iterator30 = focusables[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
                  var focusable = _step30.value;
                  focusable.removeAttribute('tabindex');
                }
              } catch (err) {
                _didIteratorError30 = true;
                _iteratorError30 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion30 && _iterator30.return != null) {
                    _iterator30.return();
                  }
                } finally {
                  if (_didIteratorError30) {
                    throw _iteratorError30;
                  }
                }
              }
            }
          }
        } // listener dispatch


        el.dispatchEvent(new CustomEvent('ondone.xt', {
          bubbles: true,
          detail: obj[type].detail
        }));
      } else if (actionCurrent === 'Off') {
        var _el$classList14;

        // reset
        (_el$classList14 = el.classList).remove.apply(_el$classList14, _toConsumableArray(self.classesOut)); // special


        if (type === 'targets' || !self.targets.length && type === 'elements') {
          // @FIX when standalone
          // appendTo
          if (options.appendTo) {
            var appendOrigin = document.querySelector('[data-xt-origin=' + self.namespace + ']');

            if (appendOrigin) {
              el.classList.add('xt-ignore', 'xt-ignore--once'); // @FIX ignore once for mount when moving

              appendOrigin.before(el);
              appendOrigin.remove();
            } else {
              el.remove();
            }
          }
        } // aria


        if (options.aria) {
          // selected
          if (type === 'elements') {
            var ariaEls = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].queryAll(el, options.ariaControls);
            var ariaEl = ariaEls.length ? ariaEls[0] : el;
            ariaEl.setAttribute('aria-selected', 'false');
          }

          if (type === 'targets') {
            // expanded
            var role = el.getAttribute('role');

            if (role === 'tabpanel' || role === 'listbox' || role === 'dialog') {
              el.setAttribute('aria-expanded', 'false');
            } // tabindex


            if (options.aria === true || options.aria.tabindex) {
              var _focusables = el.querySelectorAll(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].focusables);

              var _iteratorNormalCompletion31 = true;
              var _didIteratorError31 = false;
              var _iteratorError31 = undefined;

              try {
                for (var _iterator31 = _focusables[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {
                  var _focusable = _step31.value;

                  _focusable.setAttribute('tabindex', '-1');

                  _focusable.blur();
                }
              } catch (err) {
                _didIteratorError31 = true;
                _iteratorError31 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion31 && _iterator31.return != null) {
                    _iterator31.return();
                  }
                } finally {
                  if (_didIteratorError31) {
                    throw _iteratorError31;
                  }
                }
              }
            }
          }
        } // listener dispatch


        el.dispatchEvent(new CustomEvent('offdone.xt', {
          bubbles: true,
          detail: obj[type].detail
        }));
      } // queue


      if (!skipQueue) {
        // queue done
        if (!obj[type].instant && !obj[type].instantType) {
          var els = obj[type].queueEls;

          if (el === els[els.length - 1]) {
            // only if last element
            self.queueDone(actionCurrent, actionOther, obj, type);
          }
        }
      }
    }
    /**
     * queue done
     * @param {String} actionCurrent Current action
     * @param {String} actionOther Other action
     * @param {Object} obj Queue object
     * @param {String} type Type of element
     */

  }, {
    key: "queueDone",
    value: function queueDone(actionCurrent, actionOther, obj, type) {
      var self = this; // check

      if (obj[type]) {
        // type done
        obj[type].done = true; // check done

        var done = 0;

        for (var _type in obj) {
          if (obj[_type].done) {
            done++;
          }
        } // one done


        if (done === 1) {
          // queue progress
          self.queueProgress(actionCurrent, obj);
        } // queue


        self.queueStart(actionOther, actionCurrent, type, self.detail['queue' + actionOther].length - 1); // all done

        if (done === Object.entries(obj).length) {
          // remove queue
          self.detail['queue' + actionCurrent].pop(); // queue complete

          self.queueComplete(actionCurrent, obj);
        }
      }
    }
    /**
     * logic to execute on queue first progress
     * @param {String} actionCurrent Current action
     * @param {Object} obj Queue object
     */

  }, {
    key: "queueProgress",
    value: function queueProgress(actionCurrent, obj) {
      var self = this;
      var options = self.options;

      if (actionCurrent === 'On') {
        // special
        self.specialBackdrop(obj);
        self.specialClassHtml(actionCurrent);
        self.specialScrollbar(actionCurrent); // focus

        if (options.scrollbar) {
          var el = obj.targets ? obj.targets.queueEls[0] : obj.elements.queueEls[0];
          xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].focus.block = true;
          xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].focusLimit.on(el);
          el.focus();
        }
      } else if (actionCurrent === 'Off') {
        // special
        self.specialClassHtml(actionCurrent); // focus

        if (options.scrollbar) {
          xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].focus.block = false;
          xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].focusLimit.off();
          xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].focus.current.focus();
        }
      }
    }
    /**
     * logic to execute on queue complete
     * @param {String} actionCurrent Current action
     * @param {Object} obj Queue object
     */

  }, {
    key: "queueComplete",
    value: function queueComplete(actionCurrent, obj) {
      var self = this;
      var options = self.options;

      if (actionCurrent === 'On') {
        // auto
        if (options.auto && options.auto.time) {
          self.eventAutoStart();
        } // initial


        self.initial = false;
      } else if (actionCurrent === 'Off') {
        // special
        self.specialScrollbar(actionCurrent);
      }
    } //
    // wheel
    //

    /**
     * wheel handler
     * @param {Event} e
     */

  }, {
    key: "eventWheelHandler",
    value: function eventWheelHandler(e) {
      var self = this;
      self.eventWheelSmooth(e);
    }
    /**
     * wheel block handler
     * @param {Event} e
     */

  }, {
    key: "eventWheelBlockHandler",
    value: function eventWheelBlockHandler(e) {
      var self = this; // disabled

      if (self.disabled && !self.initial) {
        return;
      } // prevent default if not loop


      var max = self.getGroups().length - 1;
      var delta = -e.deltaY || -e.detail || e.wheelDelta || e.wheelDeltaY;

      if (delta > 0 && self.currentIndex > 0 || delta < 0 && self.currentIndex < max - 1) {
        // prevent wheel
        e.preventDefault();
        e.stopPropagation();
      }
    }
    /**
     * event wheel smooth for Xt
     * @param {Event} e
     */

  }, {
    key: "eventWheelSmooth",
    value: function eventWheelSmooth(e) {
      var self = this;
      var options = self.options;
      var el = self.detail.wheel; // disabled

      if (self.disabled && !self.initial) {
        return;
      } // delta


      var delta = -e.deltaY || -e.detail || e.wheelDelta || e.wheelDeltaY;

      if (delta === 0) {
        return;
      } // if document.scrollingElement scroll current overflow scroll


      if (el === document.scrollingElement) {
        var elFinal;
        var _iteratorNormalCompletion32 = true;
        var _didIteratorError32 = false;
        var _iteratorError32 = undefined;

        try {
          for (var _iterator32 = e.composedPath()[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
            var composed = _step32.value;

            if (composed instanceof Element) {
              var overflowY = getComputedStyle(composed).overflowY;

              if (composed === document.body) {
                composed = document.scrollingElement; // @FIX use scrollingElement when body
              }

              if (composed === document.scrollingElement || // always when scrollingElement
              overflowY === 'scroll' || // always when scroll
              overflowY === 'auto' && composed.scrollHeight > composed.clientHeight) {
                // only when scrollable
                if (overflowY === 'scroll' && window.self === window.top) {
                  // always when scroll and not iframe
                  elFinal = composed;
                } else if ((delta < 0 || composed.scrollTop > 0) && ( // limit top
                delta > 0 || composed.scrollTop < composed.scrollHeight - composed.clientHeight)) {
                  // limit bottom
                  elFinal = composed;
                } else if (window.self !== window.top) {
                  elFinal = window.top.document.scrollingElement;
                } else {
                  elFinal = window.self.document.scrollingElement;
                }

                break;
              }
            }
          }
        } catch (err) {
          _didIteratorError32 = true;
          _iteratorError32 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion32 && _iterator32.return != null) {
              _iterator32.return();
            }
          } finally {
            if (_didIteratorError32) {
              throw _iteratorError32;
            }
          }
        }

        if (!elFinal) {
          return;
        } else if (elFinal === document.body) {
          elFinal = self.object; // document.scrollingElement
        }

        el = elFinal;
      } // delta


      if (e.deltaMode === 1) {
        // deltaMode 1: by lines
        delta *= 30;
      } else if (e.deltaMode === 2) {
        // deltaMode 2: by pages
        if (options.wheel.horizontal) {
          delta *= el.offsetWidth;
        } else {
          delta *= el.offsetHeight;
        }
      } // factor


      delta *= options.wheel.factor; // instant

      if (!options.wheel.friction) {
        // wheel
        if (delta < 0) {
          self.goToNext(1);
        } else if (delta > 0) {
          self.goToPrev(1);
        } // dispatch


        var detail = self.eDetailSet(e);
        self.detail.wheel.dispatchEvent(new CustomEvent('wheelstart.xt', {
          detail: detail
        }));
        self.detail.wheel.dispatchEvent(new CustomEvent('wheelend.xt', {
          detail: detail
        })); // return

        return;
      } // min and max


      var min = self.detail.wheelMin || 0;
      var max = self.detail.wheelMax; // calculate max

      if (!self.detail.wheelMax) {
        if (!options.wheel.transform) {
          if (options.wheel.horizontal) {
            max = el.scrollWidth - el.offsetWidth;
          } else {
            max = el.scrollHeight - el.offsetHeight;
          }
        } else {
          var full = 0;

          if (options.wheel.horizontal) {
            var _iteratorNormalCompletion33 = true;
            var _didIteratorError33 = false;
            var _iteratorError33 = undefined;

            try {
              for (var _iterator33 = el.children[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {
                var child = _step33.value;
                full += child.offsetWidth;
              }
            } catch (err) {
              _didIteratorError33 = true;
              _iteratorError33 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion33 && _iterator33.return != null) {
                  _iterator33.return();
                }
              } finally {
                if (_didIteratorError33) {
                  throw _iteratorError33;
                }
              }
            }

            max = full - el.offsetWidth;
          } else {
            var _iteratorNormalCompletion34 = true;
            var _didIteratorError34 = false;
            var _iteratorError34 = undefined;

            try {
              for (var _iterator34 = el.children[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {
                var _child = _step34.value;
                full += _child.offsetHeight;
              }
            } catch (err) {
              _didIteratorError34 = true;
              _iteratorError34 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion34 && _iterator34.return != null) {
                  _iterator34.return();
                }
              } finally {
                if (_didIteratorError34) {
                  throw _iteratorError34;
                }
              }
            }

            max = full - el.offsetHeight;
          }
        }
      } // calculate end


      if (!self.detail.wheelMoving) {
        // get current
        if (!options.wheel.transform) {
          if (options.wheel.horizontal) {
            self.detail.wheelCurrent = el.scrollLeft;
          } else {
            self.detail.wheelCurrent = el.scrollTop;
          }
        } else {
          if (options.wheel.horizontal) {
            self.detail.wheelCurrent = -xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].getTranslate(el)[0];
          } else {
            self.detail.wheelCurrent = -xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].getTranslate(el)[1];
          }
        } // set end


        self.detail.wheelEnd = self.detail.wheelCurrent - delta;
      } else {
        // set end
        self.detail.wheelEnd = self.detail.wheelEnd - delta;
      } // friction to limit


      if (options.wheel.limit) {
        // limit
        self.detail.wheelEnd = Math.max(min, Math.min(self.detail.wheelEnd, max));
      } // propagate if already at min or max


      if (self.detail.wheelMin && self.detail.wheelMax) {
        // only when setting wheelMin and wheelMax
        if (delta < 0) {
          if (self.detail.wheelCurrent >= max) {
            return;
          }
        } else if (delta > 0) {
          if (self.detail.wheelCurrent <= min) {
            return;
          }
        }
      } // prevent wheel


      e.preventDefault(); // moving

      if (!self.detail.wheelMoving) {
        self.detail.wheelMoving = true; // dispatch

        var _detail = self.eDetailSet();

        _detail.wheelX = -self.detail.wheelCurrent;
        self.detail.wheel.dispatchEvent(new CustomEvent('wheelstart.xt', {
          detail: _detail
        })); // friction

        self.eventFrictionSmooth(el, min, max);
      }
    }
    /**
     * event friction smooth for Xt
     * @param {Node|HTMLElement|EventTarget|Window} el
     * @param {Number} min Minimum value
     * @param {Number} max Maximum value
     */

  }, {
    key: "eventFrictionSmooth",
    value: function eventFrictionSmooth(el, min, max) {
      var self = this;
      var options = self.options; // disabled

      if (self.disabled && !self.initial) {
        return;
      } // vars


      var delta = self.detail.wheelEnd - self.detail.wheelCurrent;
      var deltaAbs = Math.abs(delta);
      var sign = Math.sign(delta); // momentum

      var fncFriction = options.wheel.friction;

      if (deltaAbs >= options.wheel.frictionLimit) {
        self.detail.wheelCurrent += fncFriction(deltaAbs) * sign;
      } else {
        self.detail.wheelCurrent = self.detail.wheelEnd;
      } // set


      if (!options.wheel.transform) {
        if (options.wheel.horizontal) {
          el.scrollLeft = self.detail.wheelCurrent;
        } else {
          el.scrollTop = self.detail.wheelCurrent;
        }
      } else {
        if (options.wheel.horizontal) {
          el.style.transform = 'translateX(' + -self.detail.wheelCurrent + 'px)';
        } else {
          el.style.transform = 'translateY(' + -self.detail.wheelCurrent + 'px)';
        }
      } // loop


      if (self.detail.wheelCurrent > min && self.detail.wheelCurrent < max && // limit
      deltaAbs >= options.wheel.frictionLimit) {
        // frictionLimit
        // friction
        cancelAnimationFrame(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(self.detail.wheel, self.componentNamespace + 'WheelSmoothFrame'));
        xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(self.detail.wheel, self.componentNamespace + 'WheelSmoothFrame', requestAnimationFrame(function () {
          self.eventFrictionSmooth(el, min, max);
        })); // dispatch

        var detail = self.eDetailSet();
        detail.wheelX = -self.detail.wheelCurrent;
        self.detail.wheel.dispatchEvent(new CustomEvent('wheel.xt', {
          detail: detail
        }));
      } else {
        // moving
        self.detail.wheelMoving = false; // vars

        self.detail.wheelEnd = false; // dispatch

        var _detail2 = self.eDetailSet();

        _detail2.wheelX = -self.detail.wheelCurrent;
        self.detail.wheel.dispatchEvent(new CustomEvent('wheelend.xt', {
          detail: _detail2
        }));
      }
    }
    /**
     * event wheel stop for Xt
     */

  }, {
    key: "eventWheelStop",
    value: function eventWheelStop() {
      var self = this;
      var el = self.detail.wheel;
      cancelAnimationFrame(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'WheelSmoothFrame'));
      self.detail.wheelMoving = false;
    } //
    // special
    //

    /**
     * add or remove close events on element
     * @param {String} actionCurrent Current action
     * @param {Node|HTMLElement|EventTarget|Window} el Element
     * @param {Node|HTMLElement|EventTarget|Window} single Element to toggle
     */

  }, {
    key: "specialClose",
    value: function specialClose(actionCurrent, el) {
      var single = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var self = this;
      var options = self.options;

      if (actionCurrent === 'On') {
        // closeInside
        if (options.closeInside) {
          var closeElements = el.querySelectorAll(options.closeInside);
          requestAnimationFrame(function () {
            var _iteratorNormalCompletion35 = true;
            var _didIteratorError35 = false;
            var _iteratorError35 = undefined;

            try {
              for (var _iterator35 = closeElements[Symbol.iterator](), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {
                var closeElement = _step35.value;
                var specialCloseInsideHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(closeElement, 'click.close' + '.' + self.namespace, self.eventSpecialCloseInsideHandler.bind(self).bind(self, closeElement, single));
                closeElement.addEventListener('click', specialCloseInsideHandler);
              }
            } catch (err) {
              _didIteratorError35 = true;
              _iteratorError35 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion35 && _iterator35.return != null) {
                  _iterator35.return();
                }
              } finally {
                if (_didIteratorError35) {
                  throw _iteratorError35;
                }
              }
            }
          });
        } // closeOutside


        if (options.closeOutside) {
          var _closeElements = document.querySelectorAll(options.closeOutside);

          requestAnimationFrame(function () {
            var _iteratorNormalCompletion36 = true;
            var _didIteratorError36 = false;
            var _iteratorError36 = undefined;

            try {
              for (var _iterator36 = _closeElements[Symbol.iterator](), _step36; !(_iteratorNormalCompletion36 = (_step36 = _iterator36.next()).done); _iteratorNormalCompletion36 = true) {
                var closeElement = _step36.value;
                var specialCloseOutsideHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(closeElement, 'click.close' + '.' + self.namespace, self.eventSpecialCloseOutsideHandler.bind(self).bind(self, el, single));
                closeElement.addEventListener('click', specialCloseOutsideHandler);
              }
            } catch (err) {
              _didIteratorError36 = true;
              _iteratorError36 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion36 && _iterator36.return != null) {
                  _iterator36.return();
                }
              } finally {
                if (_didIteratorError36) {
                  throw _iteratorError36;
                }
              }
            }
          });
        }
      } else if (actionCurrent === 'Off') {
        // closeInside
        if (options.closeInside) {
          var _closeElements2 = el.querySelectorAll(options.closeInside);

          var _iteratorNormalCompletion37 = true;
          var _didIteratorError37 = false;
          var _iteratorError37 = undefined;

          try {
            for (var _iterator37 = _closeElements2[Symbol.iterator](), _step37; !(_iteratorNormalCompletion37 = (_step37 = _iterator37.next()).done); _iteratorNormalCompletion37 = true) {
              var closeElement = _step37.value;
              var specialCloseInsideHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(closeElement, 'click.close' + '.' + self.namespace);
              closeElement.removeEventListener('click', specialCloseInsideHandler);
            }
          } catch (err) {
            _didIteratorError37 = true;
            _iteratorError37 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion37 && _iterator37.return != null) {
                _iterator37.return();
              }
            } finally {
              if (_didIteratorError37) {
                throw _iteratorError37;
              }
            }
          }
        } // closeOutside


        if (options.closeOutside) {
          var _closeElements3 = document.querySelectorAll(options.closeOutside);

          var _iteratorNormalCompletion38 = true;
          var _didIteratorError38 = false;
          var _iteratorError38 = undefined;

          try {
            for (var _iterator38 = _closeElements3[Symbol.iterator](), _step38; !(_iteratorNormalCompletion38 = (_step38 = _iterator38.next()).done); _iteratorNormalCompletion38 = true) {
              var _closeElement = _step38.value;
              var specialCloseOutsideHandler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(_closeElement, 'click.close' + '.' + self.namespace);

              _closeElement.removeEventListener('click', specialCloseOutsideHandler);
            }
          } catch (err) {
            _didIteratorError38 = true;
            _iteratorError38 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion38 && _iterator38.return != null) {
                _iterator38.return();
              }
            } finally {
              if (_didIteratorError38) {
                throw _iteratorError38;
              }
            }
          }
        }
      }
    }
    /**
     * specialClose on handler
     * @param {Node|HTMLElement|EventTarget|Window} checkEl
     * @param {Node|HTMLElement|EventTarget|Window} single
     * @param {Event} e
     */

  }, {
    key: "eventSpecialCloseInsideHandler",
    value: function eventSpecialCloseInsideHandler(checkEl, single, e) {
      var self = this; // prevent closing when nested and moved (ex: overlay)

      if (!xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].checkNested(checkEl, self.targets)) {
        return;
      } // handler


      if (xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].checkNested(e.target, xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].arrSingle(checkEl))) {
        self.eventOff(single);
      }
    }
    /**
     * specialClose off handler
     * @param {Node|HTMLElement|EventTarget|Window} checkEl
     * @param {Node|HTMLElement|EventTarget|Window} single
     * @param {Event} e
     */

  }, {
    key: "eventSpecialCloseOutsideHandler",
    value: function eventSpecialCloseOutsideHandler(checkEl, single, e) {
      var self = this; // handler

      if (!xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].checkNested(e.target, xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].arrSingle(checkEl))) {
        self.eventOff(single);
      }
    }
    /**
     * open or close or reset collapse
     * @param {String} actionCurrent Current action
     * @param {Node|HTMLElement|EventTarget|Window} el Element
     * @param {String} before Before content
     * @param {String} after After content
     */

  }, {
    key: "specialCollapse",
    value: function specialCollapse(actionCurrent, el, before, after) {
      if (el instanceof HTMLElement) {
        if (actionCurrent === 'On') {
          if (before === 'xt-collapse--height') {
            cancelAnimationFrame(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'CollapseFrame'));
            xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'CollapseFrame', requestAnimationFrame(function () {
              el.classList.add('xt-hide', 'trans-anim-none');
              el.style.height = 'auto';
              var h = el.clientHeight + 'px';
              el.style.height = '0';
              cancelAnimationFrame(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'CollapseFrame'));
              xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'CollapseFrame', requestAnimationFrame(function () {
                el.classList.remove('xt-hide', 'trans-anim-none');
                el.style.height = h;
              }));
            }));
          }

          if (after === 'xt-collapse--width') {
            cancelAnimationFrame(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'CollapseFrame'));
            xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'CollapseFrame', requestAnimationFrame(function () {
              el.classList.add('xt-hide', 'trans-anim-none');
              el.style.width = 'auto';
              var w = el.clientHeight + 'px';
              el.style.width = '0';
              cancelAnimationFrame(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'CollapseFrame'));
              xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'CollapseFrame', requestAnimationFrame(function () {
                el.classList.remove('xt-hide', 'trans-anim-none');
                el.style.width = w;
              })).toString();
            }));
          }
        } else if (actionCurrent === 'Off') {
          if (before === 'xt-collapse--height') {
            var h = el.offsetHeight + 'px';
            cancelAnimationFrame(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'CollapseFrame'));
            xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'CollapseFrame', requestAnimationFrame(function () {
              el.classList.remove('xt-hide', 'trans-anim-none');
              el.style.height = h;
              cancelAnimationFrame(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'CollapseFrame'));
              xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.set(el, self.componentNamespace + 'CollapseFrame', requestAnimationFrame(function () {
                el.style.height = '0';
              }));
            }));
          }

          if (after === 'xt-collapse--width') {
            var w = el.offsetWidth + 'px';
            cancelAnimationFrame(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'CollapseFrame'));
            xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(el, self.componentNamespace + 'CollapseFrame', requestAnimationFrame(function () {
              el.classList.remove('xt-hide', 'trans-anim-none');
              el.style.width = w;
              cancelAnimationFrame(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(el, self.componentNamespace + 'CollapseFrame'));
              xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.put(el, self.componentNamespace + 'CollapseFrame', requestAnimationFrame(function () {
                el.style.width = '0';
              }));
            }));
          }
        } else if (actionCurrent === 'Reset') {
          if (before === 'xt-collapse--height') {
            el.style.height = 'inherit';
          }

          if (after === 'xt-collapse--width') {
            el.style.width = 'inherit';
          }
        }
      }
    }
    /**
     * scrollbar activation
     * @param {String} actionCurrent Current action
     */

  }, {
    key: "specialScrollbar",
    value: function specialScrollbar(actionCurrent) {
      var self = this;
      var options = self.options;

      if (actionCurrent === 'On') {
        // scrollbar on
        if (options.scrollbar) {
          // checks
          xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].scrollbar.add(self.namespace); // check fixed

          var checks = document.querySelectorAll('.xt-fixed--check, .xt-fixed--check > *');
          var _iteratorNormalCompletion39 = true;
          var _didIteratorError39 = false;
          var _iteratorError39 = undefined;

          try {
            for (var _iterator39 = checks[Symbol.iterator](), _step39; !(_iteratorNormalCompletion39 = (_step39 = _iterator39.next()).done); _iteratorNormalCompletion39 = true) {
              var check = _step39.value;
              var style = getComputedStyle(check);

              if (style.position === 'fixed') {
                check.classList.add('xt-fixed');
              } else {
                check.classList.remove('xt-fixed');
              }
            } // scrollbar

          } catch (err) {
            _didIteratorError39 = true;
            _iteratorError39 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion39 && _iterator39.return != null) {
                _iterator39.return();
              }
            } finally {
              if (_didIteratorError39) {
                throw _iteratorError39;
              }
            }
          }

          var container = document.documentElement;
          container.classList.add('xt-scrollbar');
          xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].scrollbarSpaceOn(container);
        }
      } else if (actionCurrent === 'Off') {
        // scrollbar off
        if (options.scrollbar) {
          // checks
          xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].scrollbar.remove(self.namespace);

          if (!xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].scrollbar.get().length) {
            // scrollbar
            var _container = document.documentElement;

            _container.classList.remove('xt-scrollbar');

            xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].scrollbarSpaceOff(_container);
          }
        }
      }
    }
    /**
     * add or remove html class
     * @param {String} actionCurrent Current action
     */

  }, {
    key: "specialClassHtml",
    value: function specialClassHtml(actionCurrent) {
      var self = this;
      var options = self.options;

      if (actionCurrent === 'On') {
        // class on
        if (options.classHtml) {
          var _container$classList;

          var container = document.documentElement;

          (_container$classList = container.classList).add.apply(_container$classList, _toConsumableArray(options.classHtml.split(' ')));
        }
      } else if (actionCurrent === 'Off') {
        // class off
        if (options.classHtml) {
          var _container2$classList;

          var _container2 = document.documentElement;

          (_container2$classList = _container2.classList).remove.apply(_container2$classList, _toConsumableArray(options.classHtml.split(' ')));
        }
      }
    }
    /**
     * backdrop append to element
     * @param {Object} obj Queue object
     */

  }, {
    key: "specialBackdrop",
    value: function specialBackdrop(obj) {
      var self = this;
      var options = self.options; // backdrop

      if (options.backdrop) {
        var elements = typeof options.backdrop === 'string' && obj[options.backdrop] ? xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].arrSingle(obj[options.backdrop].queueEls) : xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].arrSingle(self.object);
        var _iteratorNormalCompletion40 = true;
        var _didIteratorError40 = false;
        var _iteratorError40 = undefined;

        try {
          var _loop4 = function _loop4() {
            var element = _step40.value;
            var backdrop = element.querySelectorAll('.backdrop');

            if (!backdrop.length) {
              backdrop = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].createElement('<div class="backdrop xt-ignore"></div>');
              element.append(backdrop); // @FIX pass wheel event or when you mousewheel over .backdrop it doesn't scroll

              var eWheel = 'onwheel' in backdrop ? 'wheel' : backdrop.onmousewheel !== undefined ? 'mousewheel' : 'DOMMouseScroll';
              backdrop.addEventListener(eWheel, function (e) {
                var delta = -e.deltaY || -e.detail || e.wheelDelta || e.wheelDeltaY;
                element.scrollTop -= delta;
              }, xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].passiveSupported ? {
                passive: false
              } : false);
            }
          };

          for (var _iterator40 = elements[Symbol.iterator](), _step40; !(_iteratorNormalCompletion40 = (_step40 = _iterator40.next()).done); _iteratorNormalCompletion40 = true) {
            _loop4();
          }
        } catch (err) {
          _didIteratorError40 = true;
          _iteratorError40 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion40 && _iterator40.return != null) {
              _iterator40.return();
            }
          } finally {
            if (_didIteratorError40) {
              throw _iteratorError40;
            }
          }
        }
      }
    }
    /**
     * center position on activation
     * @param {Node|HTMLElement|EventTarget|Window} el Element
     * @param {String} before Before content
     * @param {String} after After content
     */

  }, {
    key: "specialCenter",
    value: function specialCenter(el, before, after) {
      var self = this; // specialCenter

      if (before === 'xt-drop--center') {
        var add = self.object.clientWidth;
        var remove = el.clientWidth;
        el.style.left = (add - remove) / 2 + 'px';
      }
    }
    /**
     * middle position on activation
     * @param {Node|HTMLElement|EventTarget|Window} el Element
     * @param {String} before Before content
     * @param {String} after After content
     */

  }, {
    key: "specialMiddle",
    value: function specialMiddle(el, before, after) {
      var self = this; // specialMiddle

      if (after === 'xt-drop--middle') {
        var add = self.object.clientHeight;
        var remove = el.clientHeight;
        el.style.top = (add - remove) / 2 + 'px';
      }
    } //
    // goto
    //

    /**
     * activate next element
     * @param {Number} amount
     * @param {Boolean} force
     * @param {Boolean} loop
     */

  }, {
    key: "goToNext",
    value: function goToNext() {
      var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var loop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var self = this; // goToIndex

      var index = 0;

      if (self.currentIndex !== null) {
        index = self.currentIndex + amount;
      }

      self.detail.inverseForce = false;
      self.goToIndex(index, force, loop);
    }
    /**
     * activate prev element
     * @param {Number} amount
     * @param {Boolean} force
     * @param {Boolean} loop
     */

  }, {
    key: "goToPrev",
    value: function goToPrev() {
      var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var loop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var self = this; // goToIndex

      var index = self.getGroups().length - 1;

      if (self.currentIndex !== null) {
        index = self.currentIndex - amount;
      }

      self.detail.inverseForce = true;
      self.goToIndex(index, force, loop);
    }
    /**
     * activate index element
     * @param {Number} index
     * @param {Boolean} force
     * @param {Boolean} loop
     */

  }, {
    key: "goToIndex",
    value: function goToIndex(index) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var loop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var self = this;
      var options = self.options; // check

      var max = self.getGroups().length - 1;

      if (index > max) {
        if (loop || loop === null && options.loop) {
          index = index - max - 1;
          index = index > max ? max : index; // prevent overflow
        } else {
          index = max;
        }
      } else if (index < 0) {
        if (loop || loop == null && options.loop) {
          index = index + max + 1;
          index = index < 0 ? 0 : index; // prevent overflow
        } else {
          index = 0;
        }
      } // go


      var current = self.getGroups()[index];
      self.eventOn(current, force);
    } //
    // status
    //

    /**
     * status handler
     * @param {Event} e
     */

  }, {
    key: "eventStatusHandler",
    value: function eventStatusHandler() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var self = this; // handler

      xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].eventDelay(e, self.object, function () {
        self.eventStatus();
      }, self.componentNamespace + 'Resize');
    }
    /**
     * status
     */

  }, {
    key: "eventStatus",
    value: function eventStatus() {
      var self = this; // check disabled

      if (self.object instanceof HTMLElement && // @FIX not on window
      getComputedStyle(self.object, ':after').getPropertyValue('content').replace(/['"]+/g, '') === 'xt-disable') {
        self.disable();
      } else if (self.disabled) {
        self.enable();
      }
    }
    /**
     * disable
     */

  }, {
    key: "disable",
    value: function disable() {
      var self = this; // disable

      self.disabled = true;
      self.object.classList.add('xt-disabled');
    }
    /**
     * disable
     */

  }, {
    key: "enable",
    value: function enable() {
      var self = this; // enable

      self.disabled = false;
      self.object.classList.remove('xt-disabled');
    } //
    // destroy
    //

    /**
     * destroy
     */

  }, {
    key: "destroy",
    value: function destroy() {
      var weak = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var self = this; // stop auto

      clearInterval(xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(self.object, self.componentNamespace + 'AutoStartInterval')); // stop queue

      self.queueStopAll(); // @FIX autoClose with appendTo outside ajax
      // remove events

      if (self.destroyElements) {
        var _iteratorNormalCompletion41 = true;
        var _didIteratorError41 = false;
        var _iteratorError41 = undefined;

        try {
          for (var _iterator41 = self.destroyElements[Symbol.iterator](), _step41; !(_iteratorNormalCompletion41 = (_step41 = _iterator41.next()).done); _iteratorNormalCompletion41 = true) {
            var element = _step41.value;
            var storages = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.getAll(element);

            if (storages) {
              var _iteratorNormalCompletion42 = true;
              var _didIteratorError42 = false;
              var _iteratorError42 = undefined;

              try {
                for (var _iterator42 = storages[Symbol.iterator](), _step42; !(_iteratorNormalCompletion42 = (_step42 = _iterator42.next()).done); _iteratorNormalCompletion42 = true) {
                  var _step42$value = _slicedToArray(_step42.value, 1),
                      key = _step42$value[0];

                  if (key) {
                    if (key.endsWith(self.namespace)) {
                      var handler = xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.get(element, key);

                      if (typeof handler === 'function') {
                        var events = key.split('.')[0].split(' ');
                        var _iteratorNormalCompletion43 = true;
                        var _didIteratorError43 = false;
                        var _iteratorError43 = undefined;

                        try {
                          for (var _iterator43 = events[Symbol.iterator](), _step43; !(_iteratorNormalCompletion43 = (_step43 = _iterator43.next()).done); _iteratorNormalCompletion43 = true) {
                            var event = _step43.value;
                            element.removeEventListener(event, handler);
                            element.removeEventListener(event, handler, true);
                            element.removeEventListener(event, handler, {
                              passive: true
                            });
                            xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].dataStorage.remove(element, key);
                          }
                        } catch (err) {
                          _didIteratorError43 = true;
                          _iteratorError43 = err;
                        } finally {
                          try {
                            if (!_iteratorNormalCompletion43 && _iterator43.return != null) {
                              _iterator43.return();
                            }
                          } finally {
                            if (_didIteratorError43) {
                              throw _iteratorError43;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } catch (err) {
                _didIteratorError42 = true;
                _iteratorError42 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion42 && _iterator42.return != null) {
                    _iterator42.return();
                  }
                } finally {
                  if (_didIteratorError42) {
                    throw _iteratorError42;
                  }
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError41 = true;
          _iteratorError41 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion41 && _iterator41.return != null) {
              _iterator41.return();
            }
          } finally {
            if (_didIteratorError41) {
              throw _iteratorError41;
            }
          }
        }
      } // not weak destroy


      if (!weak) {
        xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].remove(self.componentName, self.object);

        if (self.unmount) {
          self.unmount();
        }

        delete this;
      }
    }
  }]);

  return Toggle;
}(); //
// option
//


Toggle.componentName = 'xt-toggle';
Toggle.optionsDefaultSuper = {
  elements: ':scope > a, :scope > button',
  targets: ':scope > [class^="toggle--"], :scope > [class*=" toggle--"]',
  on: 'click',
  min: 0,
  max: 1,
  instant: {
    elements: true
  },
  // defaults
  class: 'active',
  classIn: 'in',
  classOut: 'out',
  classInitial: 'initial',
  classInverse: 'inverse',
  autoClose: false,
  onBlock: false,
  offBlock: false,
  loop: true,
  jump: false,
  imageLoadedInit: false,
  delayOn: false,
  delayOff: false,
  durationOn: false,
  durationOff: false,
  keyboard: {
    selector: false
  },
  auto: {
    time: false,
    step: 1,
    initial: true,
    inverse: false,
    pause: false
  },
  aria: {
    tabindex: true,
    controls: true,
    labelledby: true
  } //
  // export
  //

};
xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Toggle = Toggle; //
// observe
//

xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].mount.push({
  matches: '[data-' + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Toggle.componentName + ']',
  mount: function mount(object) {
    // init
    var self = new xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Toggle(object, object.getAttribute('data-' + xtend_library__WEBPACK_IMPORTED_MODULE_0__["Xt"].Toggle.componentName)); // unmount

    return function unmount() {
      self.destroy();
      self = null;
    };
  }
});

/***/ }),

/***/ "./src/polyfill.js":
/*!*************************!*\
  !*** ./src/polyfill.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * call only if in browser mode
 * https://www.gatsbyjs.org/docs/debugging-html-builds/#how-to-check-if-code-classlanguage-textwindowcode-is-defined
 */
if (typeof window !== 'undefined') {
  /**
   * before
   * https://github.com/jserz/js_piece/blob/master/DOM/ChildNode/before()/before().md
   */
  (function (arr) {
    arr.forEach(function (item) {
      if (item.hasOwnProperty('before')) {
        return;
      }

      Object.defineProperty(item, 'before', {
        configurable: true,
        enumerable: true,
        writable: true,
        value: function before() {
          var argArr = Array.prototype.slice.call(arguments),
              docFrag = document.createDocumentFragment();
          argArr.forEach(function (argItem) {
            var isNode = argItem instanceof Node;
            docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
          });
          this.parentNode.insertBefore(docFrag, this);
        }
      });
    });
  })([Element.prototype, CharacterData.prototype, DocumentType.prototype]);
  /**
   * after
   * https://github.com/jserz/js_piece/blob/master/DOM/ChildNode/after()/after().md
   */


  (function (arr) {
    arr.forEach(function (item) {
      if (item.hasOwnProperty('after')) {
        return;
      }

      Object.defineProperty(item, 'after', {
        configurable: true,
        enumerable: true,
        writable: true,
        value: function after() {
          var argArr = Array.prototype.slice.call(arguments),
              docFrag = document.createDocumentFragment();
          argArr.forEach(function (argItem) {
            var isNode = argItem instanceof Node;
            docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
          });
          this.parentNode.insertBefore(docFrag, this.nextSibling);
        }
      });
    });
  })([Element.prototype, CharacterData.prototype, DocumentType.prototype]);
  /**
   * :scope
   * https://github.com/jonathantneal/element-qsa-scope
   */


  (function (ElementPrototype) {
    try {
      // test for scope support
      document.querySelector(':scope *');
    } catch (error) {
      var polyfill = function polyfill(qsa) {
        return function (selectors) {
          // whether the selectors contain :scope
          var hasScope = selectors && scope.test(selectors);

          if (hasScope) {
            // fallback attribute
            var attr = 'q' + Math.floor(Math.random() * 9000000) + 1000000; // replace :scope with the fallback attribute

            arguments[0] = selectors.replace(scope, '[' + attr + ']'); // add the fallback attribute

            this.setAttribute(attr, ''); // results of the qsa

            var elementOrNodeList = qsa.apply(this, arguments); // remove the fallback attribute

            this.removeAttribute(attr); // return the results of the qsa

            return elementOrNodeList;
          } else {
            // return the results of the qsa
            return qsa.apply(this, arguments);
          }
        };
      }; // scope regex


      var scope = /:scope(?![\w-])/gi; // polyfill Element#querySelector

      var querySelectorWithScope = polyfill(ElementPrototype.querySelector);

      ElementPrototype.querySelector = function querySelector(selectors) {
        return querySelectorWithScope.apply(this, arguments);
      }; // polyfill Element#querySelectorAll


      var querySelectorAllWithScope = polyfill(ElementPrototype.querySelectorAll);

      ElementPrototype.querySelectorAll = function querySelectorAll(selectors) {
        return querySelectorAllWithScope.apply(this, arguments);
      }; // polyfill Element#matches


      if (ElementPrototype.matches) {
        var matchesWithScope = polyfill(ElementPrototype.matches);

        ElementPrototype.matches = function matches(selectors) {
          return matchesWithScope.apply(this, arguments);
        };
      } // polyfill Element#closest


      if (ElementPrototype.closest) {
        var closestWithScope = polyfill(ElementPrototype.closest);

        ElementPrototype.closest = function closest(selectors) {
          return closestWithScope.apply(this, arguments);
        };
      }
    }
  })(Element.prototype);
  /**
   * composedPath
   * https://gist.github.com/rockinghelvetica/00b9f7b5c97a16d3de75ba99192ff05c
   */


  (function (E, d, w) {
    if (!E.composedPath) {
      E.composedPath = function () {
        if (this.path) {
          return this.path;
        }

        var target = this.target;
        this.path = [];

        while (target.parentNode !== null) {
          this.path.push(target);
          target = target.parentNode;
        }

        this.path.push(d, w);
        return this.path;
      };
    }
  })(Event.prototype, document, window);
}

/***/ }),

/***/ "./src/xt.js":
/*!*******************!*\
  !*** ./src/xt.js ***!
  \*******************/
/*! exports provided: Xt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Xt", function() { return Xt; });
/* harmony import */ var xtend_library_src_polyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xtend-library/src/polyfill.js */ "./src/polyfill.js");
/* harmony import */ var xtend_library_src_polyfill_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(xtend_library_src_polyfill_js__WEBPACK_IMPORTED_MODULE_0__);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

 //
// constructor
//

var Xt = {}; //
// vars
//

Xt.debug = true;
Xt.mount = [];
Xt.unmount = [];
Xt.currents = {}; // Xt currents based on namespace (so shared between Xt objects)

Xt.resizeDelay = 100;
Xt.scrollDelay = false;
Xt.imageLoadedDelay = 50;
Xt.focusables = 'a, button, details, input, iframe, select, textarea'; //
// call only if in browser mode
// https://www.gatsbyjs.org/docs/debugging-html-builds/#how-to-check-if-code-classlanguage-textwindowcode-is-defined
//

if (typeof window !== 'undefined') {
  //
  // initialization
  //

  /**
   * ready
   * @param {Function} fnc Function to execute on dom ready
   */
  Xt.ready = function (fnc) {
    if (document.readyState === 'complete') {
      requestAnimationFrame(function () {
        fnc();
      });
    } else {
      document.addEventListener('readystatechange', function () {
        if (document.readyState === 'complete') {
          requestAnimationFrame(function () {
            fnc();
          });
        }
      });
    }
  };
  /**
   * init
   */


  Xt.ready(function () {
    Xt.stickyIndex = 500;
    Xt.setScrollbarWidth();
    Xt.windowHeightSet();
    Xt.mountCheck(document.documentElement);
    Xt.observer.disconnect();
    Xt.observer.observe(document.documentElement, {
      characterData: false,
      attributes: false,
      childList: true,
      subtree: true
    });
  }); //
  // observer
  //

  /**
   * observer
   */

  Xt.observer = new MutationObserver(function (mutationsList) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = mutationsList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var mutation = _step.value;

        if (mutation.type === 'childList') {
          // added
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = mutation.addedNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var added = _step2.value;

              if (added.nodeType === 1) {
                Xt.mountCheck(added);
              }
            } // removed

          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = mutation.removedNodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var removed = _step3.value;

              if (removed.nodeType === 1) {
                Xt.unmountCheck(removed);
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });
  /**
   * mountCheck
   * @param {Node|HTMLElement|EventTarget|Window} added
   */

  Xt.mountCheck = function () {
    var added = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.documentElement;
    var addedIgnore = added.closest('.xt-ignore');

    if (addedIgnore) {
      Xt.ignoreOnce(addedIgnore); // @FIX ignore once for mount when moving

      return;
    }

    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      var _loop = function _loop() {
        var obj = _step4.value;
        // check
        var els = [];

        if (added.matches(obj.matches)) {
          els.push(added);
        }

        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = added.querySelectorAll(obj.matches)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var element = _step5.value;
            els.push(element);
          } // call

        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
              _iterator5.return();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }

        if (els.length) {
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            var _loop2 = function _loop2() {
              var _step6$value = _slicedToArray(_step6.value, 2),
                  i = _step6$value[0],
                  el = _step6$value[1];

              var elIgnore = el.closest('.xt-ignore');

              if (elIgnore) {
                Xt.ignoreOnce(elIgnore); // @FIX ignore once for mount when moving

                return "continue";
              } // call


              requestAnimationFrame(function () {
                // @FIX react when componentDidMount
                var destroy = obj.mount(el, i, obj.matches); // object, index, matches

                if (destroy) {
                  Xt.unmount.push({
                    object: el,
                    unmount: destroy
                  });
                }
              });
            };

            for (var _iterator6 = els.entries()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var _ret = _loop2();

              if (_ret === "continue") continue;
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
                _iterator6.return();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }
        }
      };

      for (var _iterator4 = Xt.mount[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        _loop();
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
          _iterator4.return();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }
  };
  /**
   * unmountCheck
   * @param {Node|HTMLElement|EventTarget|Window} removed
   */


  Xt.unmountCheck = function () {
    var removed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.documentElement;

    if (removed.closest('.xt-ignore')) {
      return;
    }

    var _iteratorNormalCompletion7 = true;
    var _didIteratorError7 = false;
    var _iteratorError7 = undefined;

    try {
      for (var _iterator7 = Xt.unmount[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
        var obj = _step7.value;

        // check
        if (removed === obj.object || removed.contains(obj.object)) {
          if (obj.object.closest('.xt-ignore')) {
            return;
          } // call


          obj.unmount(obj);
        }
      }
    } catch (err) {
      _didIteratorError7 = true;
      _iteratorError7 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
          _iterator7.return();
        }
      } finally {
        if (_didIteratorError7) {
          throw _iteratorError7;
        }
      }
    }
  }; //
  // component
  //

  /**
   * set component
   * @param {String} name Component name
   * @param {Node|HTMLElement|EventTarget|Window} element Component's element
   * @param {Object} self Component' self
   */


  Xt.set = function (name, element, self) {
    Xt.dataStorage.set(element, name, self);
  };
  /**
   * get component
   * @param {String} name Component name
   * @param {Node|HTMLElement|EventTarget|Window} element Component's element
   */


  Xt.get = function (name, element) {
    return Xt.dataStorage.get(element, name);
  };
  /**
   * remove component
   * @param {String} name Component name
   * @param {Node|HTMLElement|EventTarget|Window} element Component's element
   */


  Xt.remove = function (name, element) {
    return Xt.dataStorage.remove(element, name);
  };
  /**
   * check defined component
   * @param {Object} self Component self
   * @param {Function} fnc Component init
   */


  Xt.checkDefined = function (self, fnc) {
    // @FIX multiple initializations
    var alreadyDefinedInstance = Xt.get(self.componentName, self.object);

    if (!alreadyDefinedInstance) {
      Xt.set(self.componentName, self.object, self);
      fnc();
    } else {
      return alreadyDefinedInstance;
    }
  }; //
  // dataStorage
  // map storage for HTML elements
  //


  Xt.dataStorage = {
    /**
     * properties
     */
    _storage: new Map(),

    /**
     * set key/obj pair on element's map
     * @param {Node|HTMLElement|EventTarget|Window} el
     * @param {String} key
     * @param {Object|Function} obj
     * @returns {Object|Function}
     */
    set: function set(el, key, obj) {
      // new map if not already there
      if (!this._storage.has(el)) {
        this._storage.set(el, new Map());
      } // set


      var getEl = this._storage.get(el);

      getEl.set(key, obj); // return

      return getEl.get(key);
    },

    /**
     * put key/obj pair on element's map, return old if exist already
     * @param {Node|HTMLElement|EventTarget|Window} el
     * @param {String} key
     * @param {Object|Function} obj
     * @returns {Object|Function}
     */
    put: function put(el, key, obj) {
      // new map if not already there
      if (!this._storage.has(el)) {
        this._storage.set(el, new Map());
      } // return if already set


      var getEl = this._storage.get(el);

      var getKey = getEl.get(key);

      if (getKey) {
        return getKey;
      } // set


      getEl.set(key, obj); // return

      return getEl.get(key);
    },

    /**
     * get obj from key on element's map
     * @param {Node|HTMLElement|EventTarget|Window} el
     * @param {String} key
     * @returns {Object|Function}
     */
    get: function get(el, key) {
      var getEl = this._storage.get(el); // null if empty


      if (!getEl) {
        return null;
      } // return


      return getEl.get(key);
    },

    /**
     * get all obj/key on element's map
     * @param {Node|HTMLElement|EventTarget|Window} el
     * @returns {Object|Function}
     */
    getAll: function getAll(el) {
      var getEl = this._storage.get(el); // null if empty


      if (!getEl) {
        return null;
      } // return


      return getEl;
    },

    /**
     * has key on element's map
     * @param {Node|HTMLElement|EventTarget|Window} el
     * @param {String} key
     * @returns {Boolean}
     */
    has: function has(el, key) {
      // return
      return this._storage.get(el).has(key);
    },

    /**
     * remove element's map key
     * @param {Node|HTMLElement|EventTarget|Window} el
     * @param {String} key
     * @returns {Boolean}
     */
    remove: function remove(el, key) {
      var getEl = this._storage.get(el); // null if empty


      if (!getEl) {
        return null;
      } // remove


      var ret = getEl.delete(key); // remove storage if empty

      if (getEl.size === false) {
        this._storage.delete(el);
      } // return


      return ret;
    } //
    // scrollbar
    // util to remember scrollbar state
    //

  };
  Xt.scrollbar = {
    /**
     * properties
     */
    currents: [],

    /**
     * get scrollbar currents
     * @returns {Array} Currents
     */
    get: function get() {
      return Xt.scrollbar.currents;
    },

    /**
     * add scrollbar currents
     * @param {Node|HTMLElement|EventTarget|Window} el Elements to be deactivated
     */
    add: function add(el) {
      Xt.scrollbar.currents.push(el);
    },

    /**
     * remove scrollbar currents
     * @param {Node|HTMLElement|EventTarget|Window} el Elements to be deactivated
     */
    remove: function remove(el) {
      Xt.scrollbar.currents = Xt.scrollbar.currents.filter(function (x) {
        return x !== el;
      });
    } //
    // focus
    // util to remember focus on key or interactions events
    //

  };
  Xt.focus = {
    /**
     * properties
     */
    block: false,
    current: null,

    /**
     * enable focus change events
     */
    on: function on() {
      // event key
      var focusChangeKeyHandler = Xt.dataStorage.put(document, 'keyup.focus', Xt.focus.changeKey);
      document.addEventListener('keyup', focusChangeKeyHandler); // event mouse

      var focusChangeOtherHandler = Xt.dataStorage.get(document, 'mousedown touchstart pointerdown.focus');
      document.removeEventListener('mousedown', focusChangeOtherHandler);
      document.removeEventListener('touchstart', focusChangeOtherHandler);
      document.removeEventListener('pointerdown', focusChangeOtherHandler);
    },

    /**
     * disable focus change events
     */
    off: function off() {
      // event
      var focusChangeKeyHandler = Xt.dataStorage.get(document, 'keyup.focus');
      document.removeEventListener('keyup', focusChangeKeyHandler); // event mouse

      var focusChangeOtherHandler = Xt.dataStorage.put(document, 'mousedown touchstart pointerdown.focus', Xt.focus.changeOther);
      document.addEventListener('mousedown', focusChangeOtherHandler);
      document.addEventListener('touchstart', focusChangeOtherHandler, Xt.passiveSupported ? {
        passive: true
      } : false);
      document.addEventListener('pointerdown', focusChangeOtherHandler, Xt.passiveSupported ? {
        passive: true
      } : false);
    },

    /**
     * focus change on key events
     * @param {Event} e Event
     */
    changeKey: function changeKey(e) {
      var code = e.keyCode ? e.keyCode : e.which;

      if (code === 9) {
        if (!Xt.focus.block) {
          // remember Xt.focus
          Xt.focus.current = document.activeElement;
        }

        if (!document.documentElement.classList.contains('xt-focus')) {
          // html.xt-focus
          document.documentElement.classList.add('xt-focus'); // switch mode

          Xt.focus.off();
        }
      }
    },

    /**
     * focus change on other events
     * @param {Event} e Event
     */
    changeOther: function changeOther(e) {
      if (!Xt.focus.block) {
        // remember Xt.focus
        Xt.focus.current = e.target;
      }

      if (document.documentElement.classList.contains('xt-focus')) {
        // html.xt-focus
        document.documentElement.classList.remove('xt-focus'); // switch mode

        Xt.focus.on();
      }
    }
  };
  requestAnimationFrame(function () {
    Xt.focus.on();
  }); //
  // focusLimit
  // util to limit focus inside HTML elements
  //

  Xt.focusLimit = {
    /**
     * activate focusLimit to an element
     * @param {Node|HTMLElement|EventTarget|Window} el Element
     */
    on: function on(el) {
      // @FIX Xt.focus when clicking and not used tab before
      Xt.focus.current = Xt.focus.current ? Xt.focus.current : document.activeElement; // vars

      var focusables = el.querySelectorAll(Xt.focusables);
      focusables = Array.from(focusables).filter(function (x) {
        return x.matches(':not([disabled]), :not([tabindex="-1"])');
      }); // filter out parent

      if (focusables.length) {
        var first = focusables[0];
        var last = focusables[focusables.length - 1]; // event

        var focusLimitHandler = Xt.dataStorage.put(document, 'keyup.focusLimit', Xt.focusLimit.limit.bind(this).bind(this, focusables, first, last));
        document.addEventListener('keyup', focusLimitHandler);
      }
    },

    /**
     * deactivate focusLimit to an element
     */
    off: function off() {
      // event
      var focusLimitHandler = Xt.dataStorage.get(document, 'keyup.focusLimit');
      document.removeEventListener('keyup', focusLimitHandler);
    },

    /**
     * limit even on focus when activated
     * @param {NodeList|Array} focusables Focusables elements
     * @param {Node|HTMLElement|EventTarget|Window} first First focusable element
     * @param {Node|HTMLElement|EventTarget|Window} last Last focusable element
     * @param {Event} e Event
     */
    limit: function limit(focusables, first, last, e) {
      var code = e.keyCode ? e.keyCode : e.which;

      if (code === 9) {
        if (!focusables.includes(document.activeElement)) {
          if (e.shiftKey) {
            last.focus();
            e.preventDefault();
          } else {
            first.focus();
            e.preventDefault();
          }
        }
      }
    } //
    // friction
    // util to friction values
    //

  };

  Xt.friction = function (el, obj) {
    var xCurrent = Xt.getTranslate(el)[0];
    var yCurrent = Xt.getTranslate(el)[1];
    var xDist = obj.x - xCurrent;
    var yDist = obj.y - yCurrent; // momentum

    var fncFriction;

    if (obj.friction === false) {
      fncFriction = false;
    } else if (obj.friction === undefined) {
      fncFriction = function fncFriction(delta) {
        return delta / 9;
      };
    } else {
      fncFriction = obj.friction;
    }

    if (fncFriction) {
      xCurrent += fncFriction(Math.abs(xDist)) * Math.sign(xDist);
      yCurrent += fncFriction(Math.abs(yDist)) * Math.sign(yDist); // set

      requestAnimationFrame(function () {
        el.style.transform = 'translateX(' + xCurrent + 'px) translateY(' + yCurrent + 'px)';
      });
    } else {
      xCurrent = obj.x;
      yCurrent = obj.y; // set

      el.style.transform = 'translateX(' + xCurrent + 'px) translateY(' + yCurrent + 'px)';
    } // loop


    if (fncFriction) {
      var frictionLimit = obj.frictionLimit || 1.5;
      xDist = obj.x - xCurrent;
      yDist = obj.y - yCurrent;
      cancelAnimationFrame(Xt.dataStorage.get(el, 'xtFrictionFrame'));

      if (Math.abs(xDist) >= frictionLimit || Math.abs(yDist >= frictionLimit)) {
        Xt.dataStorage.set(el, 'xtFrictionFrame', requestAnimationFrame(function () {
          Xt.friction(el, obj);
        }));
      }
    }
  }; //
  // util
  //

  /**
   * Return translate values https://gist.github.com/aderaaij/a6b666bf756b2db1596b366da921755d
   * @param {Node|HTMLElement|EventTarget|Window} element Element to check target
   * @return {Array} Values [x, y]
   */

  /*
  USAGE:
  Xt.getTranslate(el)[0]; // for translateX
  Xt.getTranslate(el)[1]; // for translateY
  */


  Xt.getTranslate = function (element) {
    var transArr = [];
    var style = getComputedStyle(element);
    var transform = style.transform;
    var mat = transform.match(/^matrix3d\((.+)\)$/);

    if (mat) {
      transArr.push(parseFloat(mat[1].split(', ')[13]));
    } else {
      mat = transform.match(/^matrix\((.+)\)$/);
      mat ? transArr.push(parseFloat(mat[1].split(', ')[4])) : transArr.push(0);
      mat ? transArr.push(parseFloat(mat[1].split(', ')[5])) : transArr.push(0);
    }

    return transArr;
  };
  /**
   * Check if event target is inside elements
   * @param {Node|HTMLElement|EventTarget|Window} element Element to check target
   * @param {NodeList|Array} targets Elements to check inside
   * @return {Boolean}
   */


  Xt.checkNested = function (element, targets) {
    var result = false;
    var _iteratorNormalCompletion8 = true;
    var _didIteratorError8 = false;
    var _iteratorError8 = undefined;

    try {
      for (var _iterator8 = targets[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
        var t = _step8.value;

        if (element === t || t.contains(element)) {
          result = true;
        }
      }
    } catch (err) {
      _didIteratorError8 = true;
      _iteratorError8 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
          _iterator8.return();
        }
      } finally {
        if (_didIteratorError8) {
          throw _iteratorError8;
        }
      }
    }

    return result;
  };
  /**
   * Get unique id
   * @returns {String} Unique id
   */


  Xt.getuniqueId = function () {
    Xt.uid = Xt.uid !== undefined ? Xt.uid : 0;
    return 'xt-' + Xt.uid++;
  };
  /**
   * Get unique number
   * @returns {Number} Unique number
   */


  Xt.getStickyIndex = function () {
    return Xt.stickyIndex--;
  };
  /**
   * Merge objects
   * @param {Array} arr Array of objects to merge
   * @returns {Object} Merged object
   */


  Xt.merge = function (arr) {
    var final = {};
    var _iteratorNormalCompletion9 = true;
    var _didIteratorError9 = false;
    var _iteratorError9 = undefined;

    try {
      for (var _iterator9 = arr[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
        var obj = _step9.value;

        if (obj) {
          for (var _i2 = 0, _Object$entries = Object.entries(obj); _i2 < _Object$entries.length; _i2++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
                key = _Object$entries$_i[0],
                value = _Object$entries$_i[1];

            if (value !== null && _typeof(value) === 'object' && !Array.isArray(value) && // not array
            !value.nodeName && // not HTML elemen
            value !== window) {
              // not window
              final[key] = Xt.merge([final[key], value]);
            } else {
              final[key] = value;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError9 = true;
      _iteratorError9 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
          _iterator9.return();
        }
      } finally {
        if (_didIteratorError9) {
          throw _iteratorError9;
        }
      }
    }

    return final;
  };
  /**
   * Make an array when element is only one
   * @param {NodeList|Array|Node|HTMLElement|EventTarget|Window} el
   * @returns {NodeList|Array}
   */


  Xt.arrSingle = function (el) {
    if (!el) {
      return [];
    }

    if (el.length === undefined || el.tagName === 'FORM') {
      var arr = new Array(1);
      arr[0] = el;
      return arr;
    } else {
      return el;
    }
  };
  /**
   * Create HTML elements from html string
   * @param {String} str Html string (only 1 root html tag)
   * @return {Node} HTML elements
   */


  Xt.createElement = function (str) {
    var div = document.createElement('div');
    div.innerHTML = str.trim();
    return div.firstChild;
  };
  /**
   * autoClose inside Element
   * @param {Node|HTMLElement|EventTarget|Window} el Element container
   */


  Xt.autoClose = function (el) {
    var query = '[data-xt-namespace^="drop-xt-"]';
    var _iteratorNormalCompletion10 = true;
    var _didIteratorError10 = false;
    var _iteratorError10 = undefined;

    try {
      for (var _iterator10 = el.querySelectorAll(query)[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
        var drop = _step10.value;
        drop.dispatchEvent(new CustomEvent('off.xt'));
      }
    } catch (err) {
      _didIteratorError10 = true;
      _iteratorError10 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
          _iterator10.return();
        }
      } finally {
        if (_didIteratorError10) {
          throw _iteratorError10;
        }
      }
    }
  };
  /**
   * Set scrollbar width of document
   * @param {Boolean} force Force recalc
   */


  Xt.setScrollbarWidth = function () {
    var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (Xt.scrollbarWidth === undefined) {
      var scrollbarWidthHandler = Xt.dataStorage.put(window, 'resize.scrollbar', Xt.setScrollbarWidth.bind(this, true));
      addEventListener('resize', scrollbarWidthHandler);
    }

    if (force || Xt.scrollbarWidth === undefined) {
      // add outer
      var outer = document.createElement('div');
      outer.style.visibility = 'hidden';
      outer.style.width = '100%';
      outer.style.msOverflowStyle = 'scrollbar'; // needed for WinJS apps

      outer.classList.add('xt-ignore', 'overflow-style');
      document.body.appendChild(outer); // force scrollbars

      outer.style.overflow = 'scroll'; // add inner

      var inner = document.createElement('div');
      inner.style.width = '100%';
      inner.classList.add('xt-ignore');
      outer.appendChild(inner); // return

      var widthNoScroll = outer.offsetWidth;
      var widthWithScroll = inner.offsetWidth;
      Xt.scrollbarWidth = widthNoScroll - widthWithScroll; // remove

      outer.remove();
    }
  };
  /**
   * if full width return '' else return value in px
   * @param {Number|String} width
   * @returns {String} Value in px
   */


  Xt.normalizeWidth = function (width) {
    width = parseFloat(width);

    if (width + Xt.scrollbarWidth >= window.innerWidth) {
      width = '';
    } else {
      width += 'px';
    }

    return width;
  };
  /**
   * fix scrollbar spacing when changing overflow adding padding
   * @param {Array|Node|HTMLElement|EventTarget|Window} elements Elements to add padding
   */


  Xt.scrollbarSpaceOn = function (container) {
    var width = Xt.scrollbarWidth;
    container.style.paddingRight = width + 'px'; // backdrop

    var backdrops = container.querySelectorAll('.backdrop');
    var _iteratorNormalCompletion11 = true;
    var _didIteratorError11 = false;
    var _iteratorError11 = undefined;

    try {
      for (var _iterator11 = backdrops[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
        var backdrop = _step11.value;
        backdrop.style.right = width + 'px';
      } // xt-fixed

    } catch (err) {
      _didIteratorError11 = true;
      _iteratorError11 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
          _iterator11.return();
        }
      } finally {
        if (_didIteratorError11) {
          throw _iteratorError11;
        }
      }
    }

    var elements = container.querySelectorAll('.xt-fixed');
    var _iteratorNormalCompletion12 = true;
    var _didIteratorError12 = false;
    var _iteratorError12 = undefined;

    try {
      var _loop3 = function _loop3() {
        var element = _step12.value;
        element.style.paddingRight = '';
        var style = getComputedStyle(element);

        if (Xt.normalizeWidth(element.clientWidth) === '' || getComputedStyle(element).right) {
          // only if full width or right position
          var padding = style.paddingRight;
          var str = 'calc(' + padding + ' + ' + width + 'px)';
          element.classList.add('transition-none');
          requestAnimationFrame(function () {
            element.style.paddingRight = str;
            requestAnimationFrame(function () {
              element.classList.remove('transition-none');
            });
          });
        }
      };

      for (var _iterator12 = elements[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
        _loop3();
      }
    } catch (err) {
      _didIteratorError12 = true;
      _iteratorError12 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
          _iterator12.return();
        }
      } finally {
        if (_didIteratorError12) {
          throw _iteratorError12;
        }
      }
    }
  };
  /**
   * fix scrollbar spacing when changing overflow adding padding
   * @param {Array} elements Elements to remove padding
   */


  Xt.scrollbarSpaceOff = function (container) {
    container.style.paddingRight = ''; // backdrop

    var backdrops = container.querySelectorAll('.backdrop');
    var _iteratorNormalCompletion13 = true;
    var _didIteratorError13 = false;
    var _iteratorError13 = undefined;

    try {
      for (var _iterator13 = backdrops[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
        var backdrop = _step13.value;
        backdrop.style.right = '';
      } // xt-fixed

    } catch (err) {
      _didIteratorError13 = true;
      _iteratorError13 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
          _iterator13.return();
        }
      } finally {
        if (_didIteratorError13) {
          throw _iteratorError13;
        }
      }
    }

    var elements = container.querySelectorAll('.xt-fixed');
    var _iteratorNormalCompletion14 = true;
    var _didIteratorError14 = false;
    var _iteratorError14 = undefined;

    try {
      var _loop4 = function _loop4() {
        var element = _step14.value;
        element.classList.add('transition-none');
        requestAnimationFrame(function () {
          element.style.paddingRight = '';
          requestAnimationFrame(function () {
            element.classList.remove('transition-none');
          });
        });
      };

      for (var _iterator14 = elements[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
        _loop4();
      }
    } catch (err) {
      _didIteratorError14 = true;
      _iteratorError14 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
          _iterator14.return();
        }
      } finally {
        if (_didIteratorError14) {
          throw _iteratorError14;
        }
      }
    }
  };
  /**
   * ignoreOnce
   * @param {Node|HTMLElement|EventTarget|Window} el
   */


  Xt.ignoreOnce = function (el) {
    if (el.classList.contains('xt-ignore--once')) {
      requestAnimationFrame(function () {
        // @FIX react when componentDidMount
        requestAnimationFrame(function () {
          // @FIX react when componentDidMount
          el.classList.remove('xt-ignore', 'xt-ignore--once');
        });
      });
    }
  };
  /**
   * get transition or animation time
   * @param {Node|HTMLElement|EventTarget|Window} el Element animating
   * @param {Number} timing Force duration in milliseconds
   * @returns {Number} Time in milliseconds
   */


  Xt.animTime = function (el) {
    var timing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (timing || timing === 0) {
      return timing;
    } else {
      var style = getComputedStyle(el);
      var transition = parseFloat(style.transitionDuration) + parseFloat(style.transitionDelay);
      var animation = parseFloat(style.animationDuration) + parseFloat(style.animationDelay);

      if (transition || animation) {
        timing = Math.max(transition, animation);
      }

      return timing * 1000;
    }
  };
  /**
   * execute function after transition or animation
   * @param {Node|HTMLElement|EventTarget|Window} el Element animating
   * @param {Function} func Function to execute after transition or animation
   * @param {String} suffix Timeout suffix
   */


  Xt.animTimeout = function (el, func) {
    var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    clearTimeout(Xt.dataStorage.get(el, 'xtAnimTimeout' + suffix));
    Xt.dataStorage.set(el, 'xtAnimTimeout' + suffix, setTimeout(func, Xt.animTime(el)));
  };
  /**
   * clear animTimeout
   * @param {Node|HTMLElement|EventTarget|Window} el Element animating
   * @param {String} suffix Timeout suffix
   */


  Xt.animTimeoutClear = function (el) {
    var suffix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    clearTimeout(Xt.dataStorage.get(el, 'xtAnimTimeout' + suffix));
  };
  /**
   * return window percent if percent string
   * @param {Number|String} num Number to check
   * @returns {Number}
   */


  Xt.windowPercent = function (num) {
    if (typeof num === 'string' || num instanceof String) {
      if (num.indexOf('%') !== -1) {
        num = Xt.windowHeight * parseFloat(num) / 100;
      }
    }

    return num;
  };
  /**
   * query array of elements or element
   * @param {Node|HTMLElement|NodeList|Array} element Element to search from
   * @param {String} query Query for querySelectorAll
   * @returns {Array}
   */


  Xt.queryAll = function (element, query) {
    if (!query) {
      return [];
    }

    if (!element.length) {
      // search element
      return Xt.arrSingle(element.querySelectorAll(query));
    } else {
      // search array
      var arr = [];
      var _iteratorNormalCompletion15 = true;
      var _didIteratorError15 = false;
      var _iteratorError15 = undefined;

      try {
        for (var _iterator15 = element[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
          var el = _step15.value;
          arr.push.apply(arr, _toConsumableArray(el.querySelectorAll(query)));
        }
      } catch (err) {
        _didIteratorError15 = true;
        _iteratorError15 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion15 && _iterator15.return != null) {
            _iterator15.return();
          }
        } finally {
          if (_didIteratorError15) {
            throw _iteratorError15;
          }
        }
      }

      return arr;
    }
  };
  /**
   * check element visibility
   * @param {Node|HTMLElement|EventTarget|Window} el Element animating
   * @returns {Boolean}
   */


  Xt.visible = function (el) {
    return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
  };
  /**
   * Fix resize event multiple calls and adds delay on resize and scroll events
   * @param {Event|Object} e Event
   * @param {Node|HTMLElement|EventTarget|Window} element Element to save timeout
   * @param {Function} func Function to execute
   * @param {String} prefix Timeout prefix
   * @param {Boolean} instant If instant
   */


  Xt.eventDelay = function (e, element, func) {
    var prefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
    var instant = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var container = document.documentElement;

    if (e && e.type && (e.type === 'resize' || e.type === 'scroll')) {
      var delay = instant ? false : Xt[e.type + 'Delay'];

      if (e.type === 'resize') {
        // multiple calls check
        if (window.innerWidth === Xt.dataStorage.get(container, 'xtEventDelay')) {
          // only width no height because it changes on scroll on mobile
          return;
        } // save after a frame to execute all eventDelay


        cancelAnimationFrame(Xt.dataStorage.get(container, 'xtEventDelayFrame'));
        Xt.dataStorage.set(container, 'xtEventDelayFrame', requestAnimationFrame(function () {
          Xt.dataStorage.set(container, 'xtEventDelay', window.innerWidth);
        }));
      } // delay


      if (delay === false) {
        // func
        func(e);
      } else {
        clearTimeout(Xt.dataStorage.get(element, 'xt' + e.type + prefix + 'Timeout'));
        Xt.dataStorage.set(element, 'xt' + e.type + prefix + 'Timeout', setTimeout(function () {
          // func
          func(e);
        }, delay));
      }
    } else {
      // func
      func(e);
    }
  };

  Xt.dataStorage.set(document.documentElement, 'xtEventDelay', window.innerWidth);
  /**
   * Xt.windowHeight
   * vindow height value only on width resize to fix mobile window height changes
   */

  addEventListener('resize', function (e) {
    Xt.eventDelay(e, document.documentElement, function () {
      Xt.windowHeightSet();
    }, 'xtWindowHeight' + 'Resize', true);
  });

  Xt.windowHeightSet = function () {
    Xt.windowHeight = window.innerHeight;
    /* https://css-tricks.com/the-trick-to-viewport-units-on-mobile/
     * height: 100vh;
     * height: calc(var(--vh, 1vh) * 100);
     */

    document.documentElement.style.setProperty('--vh', Xt.windowHeight * 0.01 + 'px');
  };
  /**
   * passive events
   * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
   */


  Xt.passiveSupported = false;

  try {
    var options = {
      get passive() {
        Xt.passiveSupported = true;
      }

    };
    addEventListener('test', options, options);
    removeEventListener('test', options, options);
  } catch (err) {
    Xt.passiveSupported = false;
  } //

}

/***/ }),

/***/ "./src/xtend-core.js":
/*!***************************!*\
  !*** ./src/xtend-core.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

if (typeof window !== 'undefined') {
  __webpack_require__(/*! xtend-library/src/core/ajax/ajax.js */ "./src/core/ajax/ajax.js");

  __webpack_require__(/*! xtend-library/src/core/drop/drop.js */ "./src/core/drop/drop.js");

  __webpack_require__(/*! xtend-library/src/core/overlay/overlay.js */ "./src/core/overlay/overlay.js");

  __webpack_require__(/*! xtend-library/src/core/scroll/scroll.js */ "./src/core/scroll/scroll.js");

  __webpack_require__(/*! xtend-library/src/core/slider/slider.js */ "./src/core/slider/slider.js");

  __webpack_require__(/*! xtend-library/src/core/smooth/smooth.js */ "./src/core/smooth/smooth.js");

  __webpack_require__(/*! xtend-library/src/core/sticky/sticky.js */ "./src/core/sticky/sticky.js");

  __webpack_require__(/*! xtend-library/src/core/toggle/toggle.js */ "./src/core/toggle/toggle.js");
}

/***/ }),

/***/ 0:
/*!***********************************************!*\
  !*** multi ./dist/xtend.js ./dist/xtend.less ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./dist/xtend.js */"./dist/xtend.js");
module.exports = __webpack_require__(/*! ./dist/xtend.less */"./dist/xtend.less");


/***/ })

/******/ });
//# sourceMappingURL=xtend.min.js.map